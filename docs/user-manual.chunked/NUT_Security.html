<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10. Notes on securing NUT</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="Network UPS Tools User Manual" /><link rel="up" href="index.html" title="Network UPS Tools User Manual" /><link rel="prev" href="daisychain.html" title="9. NUT daisychain support notes" /><link rel="next" href="_glossary.html" title="A. Glossary" /><meta xmlns="" name="format-detection" content="telephone=no" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="daisychain.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="_glossary.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="NUT_Security"></a>10. Notes on securing NUT</h2></div></div></div><p>The NUT Team is very interested in providing the highest security level to its
users.</p><p>Many internal and external mechanisms exist to secure NUT. And several steps
are needed to ensure that your NUT setup meets your security requirements.</p><p>This chapter will present you these mechanisms, by increasing order of security
level. This means that the more security you need, the more mechanisms you will
have to apply.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>You may want to have a look at NUT Quality Assurance, since some
topics are related to NUT security and reliability.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="verifySourceSig"></a>10.1. How to verify the NUT source code signature</h3></div></div></div><p>In order to verify the NUT source code signature for releases, perform the
following steps:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Retrieve the <a class="ulink" href="https://www.networkupstools.org/download.html" target="_top">NUT source code</a>
  (nut-X.Y.Z.tar.gz) and the matching signature (nut-X.Y.Z.tar.gz.sig)
</li><li class="listitem"><p class="simpara">
Retrieve the <a class="ulink" href="https://www.networkupstools.org/source/nut-key.gpg" target="_top">NUT
maintainer’s signature keyring</a>:
</p><pre class="literallayout">$ gpg --fetch-keys https://www.networkupstools.org/source/nut-key.gpg</pre></li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>As of NUT 2.8.0, a new release key is used, but the <code class="literal">nut-key.gpg</code> should
be cumulative with older chain key files (includes them). You can view the key
list in a downloaded copy of the URL above with:</p><pre class="literallayout">$ gpg --with-colons --import-options import-show --dry-run --import &lt; nut-key.gpg</pre><p>…and as of this writing, it should contain two key sets for various identities
of "Arnaud Quette" and one set of "Jim Klimov".</p></div><p>Just in case, the previous key file used since NUT 2.7.3 release is stored as
<a class="ulink" href="https://www.networkupstools.org/source/nut-key-2.7.3.gpg" target="_top">NUT
old maintainer’s signature for 2.7.3-2.7.4 releases</a></p><p>In order to verify an even older release, please use
<a class="ulink" href="https://www.networkupstools.org/source/nut-old-key.gpg" target="_top">NUT
old maintainer’s signature since 2002 until 2.7.3 release</a></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Launch the GPG checking using the following command:
</p><pre class="literallayout">$ gpg --verify nut-X.Y.Z.tar.gz.sig</pre></li><li class="listitem"><p class="simpara">
You should see a message mentioning a "Good signature", with formatting which
  depends on your gpg version, like:
</p><pre class="literallayout">gpg: Signature made Thu Jun  1 00:10:16 2023 CEST
...
gpg: Good signature from "Jim Klimov ..."
...
Primary key fingerprint: B834 59F7 76B9 0224 988F  36C0 DE01 84DA 7043 DCF7
...</pre></li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The previously used maintainer’s signatures would output (with markup of
older gpg tools here):</p><pre class="literallayout">gpg: Signature made Wed Apr 15 15:55:30 2015 CEST using RSA key ID 55CA5976
gpg: Good signature from "Arnaud Quette ..."
...</pre><p>or:</p><pre class="literallayout">gpg: Signature made Thu Jul  5 16:15:05 2007 CEST using DSA key ID 204DDF1B
gpg: Good signature from "Arnaud Quette ..."
...</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_how_to_verify_the_nut_source_code_checksum"></a>10.2. How to verify the NUT source code checksum</h3></div></div></div><p>As a weaker but simpler alternative to verifying a <span class="strong"><strong>signature</strong></span>, you can verify
just the accompanying checksums of the source archive file. This is useful
primarily to check against bit-rot in original storage or in transit. As far
as disclaimers go: ideally, you should cover all provided algorithms — e.g.
MD5 and SHA256 — to minimize the chance that intentional malicious tampering
on the wire goes undetected. A myriad tools can check that on various platforms;
some examples follow:</p><pre class="literallayout"># Example original checksum to compare with, from NUT website:
$ cat nut-2.8.0.tar.gz.sha256
c3e5a708da797b7c70b653d37b1206a000fcb503b85519fe4cdf6353f792bfe5  nut-2.8.0.tar.gz</pre><pre class="literallayout"># Generate checksum of downloaded archive with perl (a NUT build dependency
# generally, though you may have to install Digest::SHA module from CPAN):
$ perl -MDigest::SHA=sha256_hex -le "print sha256_hex &lt;&gt;" nut-2.8.0.tar.gz
c3e5a708da797b7c70b653d37b1206a000fcb503b85519fe4cdf6353f792bfe5</pre><pre class="literallayout"># Generate checksum of downloaded archive with openssl (another optional
# NUT build dependency):
$ openssl sha256 nut-2.8.0.tar.gz
SHA256(nut-2.8.0.tar.gz)= c3e5a708da797b7c70b653d37b1206a000fcb503b85519fe4cdf6353f792bfe5</pre><pre class="literallayout"># Generate checksum of downloaded archive with coreutils:
$ sha256sum nut-2.8.0.tar.gz
c3e5a708da797b7c70b653d37b1206a000fcb503b85519fe4cdf6353f792bfe5  nut-2.8.0.tar.gz</pre><pre class="literallayout"># Auto-check downloaded checksum against downloaded archive with coreutils:
$ sha256sum -c nut-2.8.0.tar.gz.sha256
nut-2.8.0.tar.gz: OK</pre><pre class="literallayout"># Generate checksum of downloaded archive with GPG:
$ gpg --print-md SHA256 nut-2.8.0.tar.gz
nut-2.8.0.tar.gz: C3E5A708 DA797B7C 70B653D3 7B1206A0
                  00FCB503 B85519FE 4CDF6353 F792BFE5</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_system_level_privileges_and_ownership"></a>10.3. System level privileges and ownership</h3></div></div></div><p>All configuration files should be protected so that the world can’t read them.
Use the following commands to accomplish this:</p><pre class="literallayout">chown root:nut /etc/nut/*
chmod 640 /etc/nut/*</pre><p>Finally, the <a class="link" href="_installation_instructions.html#StatePath" title="State path creation">state path</a> directory, which holds the
communication between the driver(s) and <code class="literal">upsd</code>, should also be secured.</p><pre class="literallayout">chown root:nut /var/state/ups
chmod 0770 /var/state/ups</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_nut_level_user_privileges"></a>10.4. NUT level user privileges</h3></div></div></div><p>Administrative commands such as setting variables and the instant commands
are powerful, and access to them needs to be restricted.</p><p>NUT provides an internal mechanism to do so, through
<a class="ulink" href="../man/upsd.users.html" target="_top">upsd.users(5)</a>.</p><p>This file defines who may access instant commands and settings, and what
is available.</p><p>During the initial
<a class="link" href="Configuration_notes.html#NUT_user_creation" title="NUT user creation">NUT user creation</a>, we have created a
monitoring user for <code class="literal">upsmon</code>.</p><p>You can also create an <code class="literal">administrator</code> user in NUT with full power using:</p><pre class="literallayout">[administrator]
        password = mypass
        actions = set
        instcmds = all</pre><p>For more information on how to restrict actions and instant commands, refer
to <a class="ulink" href="../man/upsd.users.html" target="_top">upsd.users(5)</a> manual page.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>NUT administrative user definitions should be used in conjunction with
<a class="link" href="NUT_Security.html#TCP_Wrappers" title="TCP Wrappers">TCP Wrappers</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_network_access_control"></a>10.5. Network access control</h3></div></div></div><p>If you are not using NUT on a standalone setup, you will need to enforce
network access to <code class="literal">upsd</code>.</p><p>There are various ways to do so.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_nut_listen_directive"></a>NUT LISTEN directive</h4></div></div></div><p><a class="ulink" href="../man/upsd.conf.html" target="_top">upsd.conf(5)</a>.</p><pre class="literallayout">LISTEN interface port</pre><p>Bind a listening port to the interface specified by its Internet address.
This may be useful on hosts with multiple interfaces.  You should not rely
exclusively on this for security, as it can be subverted on many systems.</p><p>Listen on TCP port <code class="literal">port</code> instead of the default value which was compiled into
the code.  This overrides any value  you  may  have  set  with <code class="literal">configure
--with-port</code>.  If you don’t change it with configure or this value, <code class="literal">upsd</code> will
listen on port 3493 for this interface.</p><p>Multiple LISTEN addresses may be specified.  The default is to bind to
<code class="literal">127.0.0.1</code> if no LISTEN addresses are specified (and <code class="literal">::1</code> if IPv6 support is
compiled in).</p><pre class="literallayout">LISTEN 127.0.0.1
LISTEN 192.168.50.1
LISTEN ::1
LISTEN 2001:0db8:1234:08d3:1319:8a2e:0370:7344</pre><p>As a special case, <code class="literal">LISTEN * &lt;port&gt;</code> (with an asterisk) will try to
listen on "ANY" IP address for both IPv6 (<code class="literal">::0</code>) and IPv4 (<code class="literal">0.0.0.0</code>),
subject to <code class="literal">upsd</code> command-line arguments, or system configuration or support.
Note that if the system supports IPv4-mapped IPv6 addressing per RFC-3493,
and does not allow to disable this mode, then there may be one listening
socket to handle both address families.</p><p>This parameter will only be read at startup.  You’ll need to restart (rather
than reload) <code class="literal">upsd</code> to apply any changes made here.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_firewall"></a>Firewall</h4></div></div></div><p>NUT has its own official IANA port: 3493/tcp.</p><p>The <code class="literal">upsmon</code> process on secondary systems, as well as any other NUT client
(such as <code class="literal">upsc</code>, <code class="literal">upscmd</code>, <code class="literal">upsrw</code>, NUT-Monitor, …) connects to the <code class="literal">upsd</code>
process on the system which manages the UPS, via this TCP port. Usually an
<code class="literal">upsmon</code> process runs on the latter system in "primary" mode for the devices
connected to it.</p><p>The <code class="literal">upsd</code> process does not initiate outgoing connections.</p><p>Certain NUT drivers (for network-managed devices) can initiate their own
connections to various ports according to corresponding vendor protocol.</p><p>You should use this to restrict network access.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="UFW"></a>Uncomplicated Firewall (UFW) support</h5></div></div></div><p>NUT can tightly integrate with
<a class="ulink" href="http://en.wikipedia.org/wiki/Uncomplicated_Firewall" target="_top">Uncomplicated Firewall</a>
using the provided profile (nut.ufw.profile).</p><p>You must first install the profile on your system:</p><pre class="literallayout">$ cp nut.ufw.profile /etc/ufw/applications.d/</pre><p>To enable outside access to your local upsd, use:</p><pre class="literallayout">$ ufw allow NUT</pre><p>To restrict access to the network <span class="emphasis"><em>192.168.X.Y</em></span>, use:</p><pre class="literallayout">$ ufw allow from 192.168.0.0/16 to any app NUT</pre><p>You can also use graphical frontends, such as gui-ufw (gufw), ufw-kde
or ufw-frontends.</p><p>For more information, refer to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<a class="ulink" href="http://gufw.tuxfamily.org/" target="_top">UFW homepage</a>,
</li><li class="listitem">
<a class="ulink" href="https://launchpad.net/ufw" target="_top">UFW project page</a>,
</li><li class="listitem">
<a class="ulink" href="https://wiki.ubuntu.com/UncomplicatedFirewall" target="_top">UFW wiki</a>,
</li><li class="listitem">
UFW manual page, section APPLICATION INTEGRATION
</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="TCP_Wrappers"></a>TCP Wrappers</h4></div></div></div><p>If the server is build with tcp-wrappers support enabled, it will check if the
NUT username is allowed to connect from the client address through the
<code class="literal">/etc/hosts.allow</code> and <code class="literal">/etc/hosts.deny</code> files.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This will only be done for commands that require the user to be logged
into the server.</p></div><p><code class="literal">hosts.allow</code>:</p><pre class="literallayout">upsd : admin@127.0.0.1/32
upsd : observer@127.0.0.1/32 observer@192.168.1.0/24</pre><p><code class="literal">hosts.deny</code>:</p><pre class="literallayout">upsd : ALL</pre><p>Further details are described in <a class="ulink" href="https://linux.die.net/man/5/hosts_access" target="_top">hosts_access(5)</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_configuring_ssl"></a>10.6. Configuring SSL</h3></div></div></div><p>SSL is available as a build option (<code class="literal">--with-ssl</code>).</p><p>It encrypts sessions between <code class="literal">upsd</code> and clients, and can also be used to
authenticate servers.</p><p>This means that stealing port 3493 from <code class="literal">upsd</code> will no longer net you interesting
passwords.</p><p>Several things must happen before this will work, however. This chapter will
present these steps.</p><p>SSL is available via two back-end libraries : NSS and OpenSSL (historically).
You can choose to use one of them by specifying it with a build option
(<code class="literal">--with-nss</code> or <code class="literal">--with-openssl</code>). If neither is specified, the configure
script will try to detect one of them, with a precedence for OpenSSL.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_openssl_backend_usage"></a>OpenSSL backend usage</h4></div></div></div><p>This section describes how to enable NUT SSL support using
<a class="ulink" href="http://www.openssl.org" target="_top">OpenSSL</a>.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_install_openssl"></a>Install OpenSSL</h5></div></div></div><p>Install <a class="ulink" href="http://www.openssl.org" target="_top">OpenSSL</a> as usual, either from source
or binary packages. If using binary packages, be sure to include the developer
libraries.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_recompile_and_install_nut"></a>Recompile and install NUT</h5></div></div></div><p>Recompile NUT from source, starting with <code class="literal">configure --with-openssl</code>.</p><p>Then install everything as usual.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_create_a_certificate_and_key_for_upsd"></a>Create a certificate and key for upsd</h5></div></div></div><p>openssl (the program) should be in your PATH, unless you installed it from
source yourself, in which case it may be in <code class="literal">/usr/local/ssl/bin</code>.</p><p>Use the following command to create the certificate:</p><pre class="literallayout">openssl req -new -x509 -nodes -out upsd.crt -keyout upsd.key</pre><p>You can also put a <code class="literal">-days nnn</code> in there to set the expiration.  If
you skip this, it may default to 30 days.  This is probably not what
you want.</p><p>It will ask several questions.  What you put in there doesn’t matter a whole
lot, since nobody is going to see it for now.  Future versions of the
clients may present data from it, so you might use this opportunity to
identify each server somehow.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_figure_out_the_hash_for_the_key"></a>Figure out the hash for the key</h5></div></div></div><p>Use the following command to determine the hash of the certificate:</p><pre class="literallayout">openssl x509 -hash -noout -in upsd.crt</pre><p>You’ll get back a single line with 8 hex characters.  This is the
hash of the certificate, which is used for naming the client-side
certificate.  For the purposes of this example the hash is <span class="strong"><strong>0123abcd</strong></span>.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_install_the_client_side_certificate"></a>Install the client-side certificate</h5></div></div></div><p>Use the following commands to install the client-side certificate:</p><pre class="literallayout">mkdir &lt;certpath&gt;
chmod 0755 &lt;certpath&gt;
cp upsd.crt &lt;certpath&gt;/&lt;hash&gt;.0</pre><p>Example:</p><pre class="literallayout">mkdir /usr/local/ups/etc/certs
chmod 0755 /usr/local/ups/etc/certs
cp upsd.crt /usr/local/ups/etc/certs/0123abcd.0</pre><p>If you already have a file with that name in there, increment the
<code class="literal">0</code> part until you get a unique filename that works.</p><p>If you have multiple client systems (like <code class="literal">upsmon</code> instances in
secondary mode), be sure to install this file on them as well.</p><p>We recommend making a directory under your existing confpath to
keep everything in the same place.  Remember the path you created,
since you will need to put it in <code class="literal">upsmon.conf</code> later.</p><p>It must not be writable by unprivileged users, since someone could
insert a new client certificate and fool <code class="literal">upsmon</code> into trusting a
fake <code class="literal">upsd</code>.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_create_the_combined_file_for_upsd"></a>Create the combined file for upsd</h5></div></div></div><p>To do so, use the below commands:</p><pre class="literallayout">cat upsd.crt upsd.key &gt; upsd.pem
chown root:nut upsd.pem
chmod 0640 upsd.pem</pre><p>This file must be kept secure, since anyone possessing it could
pretend to be <code class="literal">upsd</code> and harvest authentication data if they get a
hold of port 3493.</p><p>Having it owned by <code class="literal">root</code> and readable by group <code class="literal">nut</code> allows <code class="literal">upsd</code>
to read the file without being able to change the contents.  This
is done to minimize the impact if someone should break into <code class="literal">upsd</code>.
NUT reads the key and certificate files after dropping privileges
and forking.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_note_on_certification_authorities_cas_and_signed_keys"></a>Note on certification authorities (CAs) and signed keys</h5></div></div></div><p>There are probably other ways to handle this, involving keys which have
been signed by a CA you recognize.  Contact your local SSL guru.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_install_the_server_side_certificate"></a>Install the server-side certificate</h5></div></div></div><p>Install the certificate with the following command:</p><pre class="literallayout">mv upsd.pem &lt;upsd certfile path&gt;</pre><p>Example:</p><pre class="literallayout">mv upsd.pem /usr/local/ups/etc/upsd.pem</pre><p>After that, edit your <code class="literal">upsd.conf</code> and tell it where to find it:</p><pre class="literallayout">CERTFILE /usr/local/ups/etc/upsd.pem</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_clean_up_the_temporary_files"></a>Clean up the temporary files</h5></div></div></div><pre class="literallayout">rm -f upsd.crt upsd.key</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_restart_upsd"></a>Restart upsd</h5></div></div></div><p>It should come back up without any complaints.  If it says something
about keys or certificates, then you probably missed a step.</p><p>If you run <code class="literal">upsd</code> as a separate user id (like <code class="literal">nutsrv</code>), make sure that
user can read the <code class="literal">upsd.pem</code> file.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_point_upsmon_at_the_certificates"></a>Point upsmon at the certificates</h5></div></div></div><p>Edit your <code class="literal">upsmon.conf</code>, and tell it where the <code class="literal">CERTPATH</code> is:</p><pre class="literallayout">CERTPATH &lt;path&gt;</pre><p>Example:</p><pre class="literallayout">CERTPATH /usr/local/ups/etc/certs</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_recommended_make_upsmon_verify_all_connections_with_certificates"></a>Recommended: make upsmon verify all connections with certificates</h5></div></div></div><p>Put this in <code class="literal">upsmon.conf</code>:</p><pre class="literallayout">CERTVERIFY 1</pre><p>Without this, there is no guarantee that the <code class="literal">upsd</code> is the right host.
Enabling this greatly reduces the risk of man in the middle attacks.</p><p>This effectively forces the use of SSL, so don’t use this unless
all of your <code class="literal">upsd</code> hosts are ready for SSL and have their certificates
in order.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_recommended_force_upsmon_to_use_ssl"></a>Recommended: force upsmon to use SSL</h5></div></div></div><p>Again in <code class="literal">upsmon.conf</code>:</p><pre class="literallayout">FORCESSL 1</pre><p>If you don’t use <code class="literal">CERTVERIFY 1</code>, then this will at least make sure
that nobody can sniff your sessions without a large effort.  Setting
this will make <code class="literal">upsmon</code> drop connections if the remote <code class="literal">upsd</code> doesn’t
support SSL, so don’t use it unless all of them have it running.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_nss_backend_usage"></a>NSS backend usage</h4></div></div></div><p>This section describes how to enable NUT SSL support using
<a class="ulink" href="http://www.mozilla.org/projects/security/pki/nss/" target="_top">Mozilla NSS</a>.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_install_nss"></a>Install NSS</h5></div></div></div><p>Install <a class="ulink" href="http://www.mozilla.org/projects/security/pki/nss/" target="_top">Mozilla NSS</a>
as usual, either from source or binary packages. If using binary packages,
be sure to include the developer libraries, and nss-tools (for <code class="literal">certutil</code>).</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_recompile_and_install_nut_2"></a>Recompile and install NUT</h5></div></div></div><p>Recompile NUT from source, starting with <code class="literal">configure --with-nss</code>.</p><p>Then install everything as usual.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_create_certificate_and_key_for_the_host"></a>Create certificate and key for the host</h5></div></div></div><p>NSS (package generally called libnss3-tools) will install a tool called
<code class="literal">certutil</code>.
It will be used to generate certificates and manage certificate database.</p><p>Certificates should be signed by a certification authorities (CAs).
Following commands are typical samples, contact your SSL guru or security
officer to follow your company procedures.</p><div class="itemizedlist"><p class="title"><strong>Generate a server certificate for <code class="literal">upsd</code>:</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Create a directory where store the certificate database: <code class="literal">mkdir cert_db</code>
</li><li class="listitem">
Create the certificate database : <code class="literal">certutil -N -d cert_db</code>
</li><li class="listitem">
Import the CA certificate:
        <code class="literal">certutil -A -d cert_db -n "My Root CA" -t "TC,," -a -i rootca.crt</code>
</li><li class="listitem">
Create a server certificate request (here called "My nut server"):
        <code class="literal">certutil -R -d cert_db -s "CN=My nut server,O=MyCompany,ST=MyState,C=US" -a -o server.req</code>
</li><li class="listitem">
Make your CA sign the certificate (produces server.crt)
</li><li class="listitem">
Import the signed certificate into server database:
        <code class="literal">certutil -A -d cert_db -n "My nut server" -a -i server.crt -t ",,"</code>
</li><li class="listitem">
Display the content of certificate server:
        <code class="literal">certutil -L -d cert_db</code>
</li></ul></div><p>Clients and servers in the same host could share the same certificate to
authenticate them or use different ones in same or different databases.
The same operation can be done in same or different databases to generate
other certificates.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_create_a_self_signed_ca_certificate"></a>Create a self-signed CA certificate</h5></div></div></div><p>NSS provides a way to create self-signed certificate which can acting as
CA certificate, and to sign other certificates with this CA certificate.
This method can be used to provide a CA certification chain without using
an "official" certificate authority.</p><div class="itemizedlist"><p class="title"><strong>Generate a self-signed CA certificate:</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Create a directory where store the CA certificate database: <code class="literal">mkdir CA_db</code>
</li><li class="listitem">
Create the certificate database:
        <code class="literal">certutil -N -d CA_db</code>
</li><li class="listitem">
Generate a certificate for CA:
        <code class="literal">certutil -S -d CA_db -n "My Root CA" -s "CN=My CA,O=MyCompany,ST=MyState,C=US" -t "CT,," -x -2</code>
(Do not forget to answer <code class="literal">Yes</code> to the question "Is this a CA certificate [y/N]?")
</li><li class="listitem">
Extract the CA certificate to be able to import it in <code class="literal">upsd</code> (or <code class="literal">upsmon</code>)
certificate database:
        <code class="literal">certutil -L -d CA_db -n "My Root CA" -a -o rootca.crt</code>
</li><li class="listitem">
Sign a certificate request with the CA certificate (simulate a real CA
signature):
        <code class="literal">certutil -C -d CA_db -c "My Root CA" -a -i server.req -o server.crt -2 -6</code>
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_install_the_server_side_certificate_2"></a>Install the server-side certificate</h5></div></div></div><p>Just copy the database directory (just the directory and included 3
database .db files) to the right place, such as <code class="literal">/usr/local/ups/etc/</code>:</p><pre class="literallayout">mv cert_db /usr/local/ups/etc/</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_upsd_required_certificate_database_and_self_certificate"></a>upsd (required): certificate database and self certificate</h5></div></div></div><p>Edit the <code class="literal">upsd.conf</code> to tell where find the certificate database:</p><pre class="literallayout">CERTPATH /usr/local/ups/etc/cert_db</pre><p>Also tell which is the certificate to send to clients to authenticate itself
and the password to decrypt private key associated to certificate:</p><pre class="literallayout">CERTIDENT "certificate name" "database password"</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Generally, the certificate name is the server domain name, but is not
a hard rule. The certificate can be named as useful.</p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_upsd_optional_client_authentication"></a>upsd (optional): client authentication</h5></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This functionality is disabled by default. To activate it, recompile
NUT with <code class="literal">WITH_CLIENT_CERTIFICATE_VALIDATION</code> defined:</p></div><pre class="literallayout">make CFLAGS="-DWITH_CLIENT_CERTIFICATE_VALIDATION"</pre><p>UPSD can accept three levels of client authentication. Just specify it with
the directive <code class="literal">CERTREQUEST</code> with the corresponding value in the <code class="literal">upsd.conf</code>
file:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
NO: no client authentication.
</li><li class="listitem">
REQUEST: a certificate is request to the client but it is not strictly
validated.
If the client does not send any certificate, the connection is closed.
</li><li class="listitem">
REQUIRE: a certificate is requested to the client and if it is not valid
(no validation chain) the connection is closed.
</li></ul></div><p>Like CA certificates, you can add many "trusted" client and CA certificates
in server’s certificate databases.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_upsmon_required_upsd_authentication"></a>upsmon (required): upsd authentication</h5></div></div></div><p>In order for <code class="literal">upsmon</code> to securely connect to <code class="literal">upsd</code>, it must authenticate it.
You must associate an <code class="literal">upsd</code> host name to security rules in <code class="literal">upsmon.conf</code>
with the directive <code class="literal">CERTHOST</code>.</p><p><code class="literal">CERTHOST</code> associates a hostname to a certificate name. It also determines
whether a SSL connection is mandatory, and if the server certificate must be
validated.</p><pre class="literallayout">CERTHOST "hostname" "certificate name" "certverify" "forcessl"</pre><p>If the flag <code class="literal">forcessl</code> is set to <code class="literal">1</code>, and <code class="literal">upsd</code> answers that it can not
connect with SSL, the connection closes.</p><p>If the flag <code class="literal">certverify</code> is set to <code class="literal">1</code> and the connection is done in SSL,
<code class="literal">upsd</code>'s certificate is verified and its name must be the specified
<code class="literal">"certificate name"</code>.</p><p>To prevent security leaks, you should set all <code class="literal">certverify</code> and <code class="literal">forcessl</code>
flags to <code class="literal">1</code> (force SSL connection and validate all certificates for all
peers).</p><p>You can specify <code class="literal">CERTVERIFY</code> and <code class="literal">FORCESSL</code> directive (to <code class="literal">1</code> or <code class="literal">0</code>) to
define a default security rule to apply to all host not specified with a
dedicated <code class="literal">CERTHOST</code> directive.</p><p>If a host is not specified in a <code class="literal">CERTHOST</code> directive, its expected certificate
name is its hostname.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_upsmon_optional_certificate_database_and_self_certificate"></a>upsmon (optional): certificate database and self certificate</h5></div></div></div><p>Like <code class="literal">upsd</code>, <code class="literal">upsmon</code> may need to authenticate itself (<code class="literal">upsd</code>'s <code class="literal">CERTREQUEST</code>
directive set to <code class="literal">REQUEST</code> or <code class="literal">REQUIRE</code>).</p><p>It must access to a certificate (and its private key) in a certificate
database configuring <code class="literal">CERTPATH</code> and <code class="literal">CERTIDENT</code> in <code class="literal">upsmon.conf</code> in the
same way as <code class="literal">upsd</code>.</p><pre class="literallayout">CERTPATH /usr/local/ups/etc/cert_db
CERTIDENT "certificate name" "database password"</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_restart_upsd_2"></a>Restart upsd</h4></div></div></div><p>It should come back up without any complaints.  If it says something
about keys or certificates, then you probably missed a step.</p><p>If you run <code class="literal">upsd</code> as a separate user ID (like <code class="literal">nutsrv</code>), make sure that
user can read files in the certificate directory. NUT reads the keys and
certificates after forking and dropping privileges.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_restart_upsmon"></a>Restart upsmon</h4></div></div></div><p>You should see something like this in the syslog from <code class="literal">upsd</code>:</p><pre class="literallayout">foo upsd[1234]: Client mon@localhost logged in to UPS [myups] (SSL)</pre><p>If <code class="literal">upsd</code> or <code class="literal">upsmon</code> give any error messages, or the <code class="literal">(SSL)</code> is missing,
then something isn’t right.</p><p>If in doubt about <code class="literal">upsmon</code>, start it with <code class="literal">-D</code> so it will stay in
the foreground and print debug messages.  It should print something
like this every couple of seconds:</p><pre class="literallayout">polling ups: myups@localhost [SSL]</pre><p>Obviously, if the <code class="literal">[SSL]</code> isn’t there, something’s broken.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_recommended_sniff_the_connection_to_see_it_for_yourself"></a>Recommended: sniff the connection to see it for yourself</h4></div></div></div><p>Using tcpdump, Wireshark (Ethereal), or another network sniffer tool,
tell it to monitor port 3493/tcp and see what happens.  You should only
see <code class="literal">STARTTLS</code> go out, <code class="literal">OK STARTTLS</code> come back, and the rest will be
certificate data and then seemingly random characters.</p><p>If you see any plaintext besides that (USERNAME, PASSWORD, etc.)
then something is not working.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_potential_problems"></a>Potential problems</h4></div></div></div><p>If you specify a certificate expiration date, you will eventually
see things like this in your syslog:</p><pre class="literallayout">Oct 29 07:27:25 rktoy upsmon[3789]: Poll UPS [for750@rktoy] failed -
SSL error: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE: certificate verify failed</pre><p>You can verify that it is expired by using openssl to display the date:</p><pre class="literallayout">openssl x509 -enddate -noout -in &lt;certfile&gt;</pre><p>It’ll display a date like this:</p><pre class="literallayout">notAfter=Oct 28 20:05:32 2002 GMT</pre><p>If that’s after the current date, you need to generate another cert/key
pair using the procedure above.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_conclusion"></a>Conclusion</h4></div></div></div><p>SSL support should be considered stable but purposely under-documented
since various bits of the implementation or configuration may change in
the future. In other words, if you use this and it stops working after
an upgrade, come back to this file to find out what changed.</p><p>This is why the other documentation doesn’t mention any of these
directives yet.  SSL support is a treat for those of you that RTFM.</p><p>There are also potential licensing issues for people who ship binary
packages since NUT is GPL and OpenSSL is not compatible with it.  You
can still build and use it yourself, but you can’t distribute the
results of it.  Or maybe you can.  It depends on what you consider
"essential system software", and some other legal junk that we’re not
going to touch.</p><p>Other packages have solved this by explicitly stating that an exception
has been granted.  That is (purposely) impossible here, since NUT is the
combined effort of many people, and all of them would have to agree to a
license change.  This is actually a feature, since it means nobody can
unilaterally run off with the source — not even the NUT team.</p><p>Note that the replacement of OpenSSL by Mozilla Network Security Services
(NSS) should avoid the above licensing issues.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_chrooting_and_other_forms_of_paranoia"></a>10.7. chrooting and other forms of paranoia</h3></div></div></div><p>It has been possible to run the drivers and <code class="literal">upsd</code> in a chrooted jail for
some time, but it involved a number of evil hacks.  From the 1.3 series,
a much saner chroot behavior exists, using BIND 9 as an inspiration.</p><p>The old way involved creating an entire tree, complete with libraries, a
shell (!), and many auxiliary files.  This was hard to maintain and
could have become an interesting playground for an intruder.  The new
way is minimal, and leaves little in the way of usable materials within
the jail.</p><p>This document assumes that you already have created at least one user
account for the software to use.  If you’re still letting it fall back
on "nobody", stop right here and go figure that out first.  It also
assumes that you have everything else configured and running happily all
by itself.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_generalities_2"></a>Generalities</h4></div></div></div><p>Essentially, you need to create your configuration directory and state
path in their own little world, plus a special device or two.</p><p>For the purposes of this example, the chroot jail is <code class="literal">/chroot/nut</code>.  The
programs have been built with the default prefix, so they are using
<code class="literal">/usr/local/ups</code>.  First, create the confpath and bring over a few files.</p><pre class="literallayout">mkdir -p /chroot/nut/usr/local/ups/etc
cd /chroot/nut/usr/local/ups/etc
cp -a /usr/local/ups/etc/upsd.users .
cp -a /usr/local/ups/etc/upsd.conf .
cp -a /usr/local/ups/etc/ups.conf .</pre><p>We’re using <code class="literal">cp -a</code> to maintain the permissions on those files.</p><p>Now bring over your state path, maintaining the same permissions as
before.</p><pre class="literallayout">mkdir -p /chroot/nut/var/state
cp -a /var/state/ups /chroot/nut/var/state</pre><p>Next we must put <code class="literal">/etc/localtime</code> inside the jail, or you may get very
strange readings in your syslog.  You’ll know you have this problem if
<code class="literal">upsd</code> shows up as UTC in the syslog while the rest of the system doesn’t.</p><pre class="literallayout">mkdir -p /chroot/nut/etc
cp /etc/localtime /chroot/nut/etc</pre><p>Note that this is not <code class="literal">cp -a</code>, since we want to copy the <span class="strong"><strong>content</strong></span>, not
the symlink that it may be on some systems.</p><p>Finally, create a tiny bit of <code class="literal">/dev</code> so the programs can enter the
background properly — they redirect file descriptors into the bit
bucket to make sure nothing else grabs fds 0-2.</p><pre class="literallayout">mkdir -p /chroot/nut/dev
cp -a /dev/null /chroot/nut/dev</pre><p>Try to start your driver(s) and make sure everything fires up as before.</p><pre class="literallayout">upsdrvctl -r /chroot/nut -u nutdev start</pre><p>Once your drivers are running properly, try starting <code class="literal">upsd</code>.</p><pre class="literallayout">upsd -r /chroot/nut -u nutsrv</pre><p>Check your syslog.  If nothing is complaining, try running clients like
<code class="literal">upsc</code> and <code class="literal">upsmon</code>.  If they seem happy, then you’re done.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_symlinks"></a>symlinks</h4></div></div></div><p>After you do this, you will have two copies of many things, like the
confpath and the state path.  I recommend deleting the "real"
<code class="literal">/var/state/ups</code>, replacing it with a symlink to
<code class="literal">/chroot/nut/var/state/ups</code>.  That will let other programs reference the
<code class="literal">.pid</code> files without a lot of hassle.</p><p>You can also do this with your confpath and point <code class="literal">/usr/local/ups/etc</code> (or
equivalent on your system) at <code class="literal">/chroot/nut/usr/local/ups/etc</code> unless you’re
worried about something hurting the files inside that directory.  In that
case, you should maintain a "golden" copy and push it into the chroot path
after making changes.</p><p>The <code class="literal">upsdrvctl</code> itself does not chroot, so the <code class="literal">ups.conf</code> still needs to be
in the usual confpath.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsmon"></a>upsmon</h4></div></div></div><p>This has not yet been applied to <code class="literal">upsmon</code>, since it can be quite
complicated when there are notifiers that need to be run.  One
possibility would be for <code class="literal">upsmon</code> to have three instances:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
privileged root parent that listens for a shutdown command
</li><li class="listitem">
unprivileged child that listens for notify events
</li><li class="listitem">
unprivileged chrooted child that does network I/O
</li></ul></div><p>This one is messy, and may not happen for some time, if ever.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_config_files"></a>Config files</h4></div></div></div><p>You may now set <code class="literal">chroot=</code> and <code class="literal">user=</code> in the global section of <code class="literal">ups.conf</code>.</p><p>The <code class="literal">upsd</code> chroots before opening any config files, so there is no way to
add support for that in <code class="literal">upsd.conf</code> at the present time.</p></div></div></div><div xmlns="" class="navfooter nut_footer"><hr />
		Last updated 2025-08-06 18:00:37 -- Network UPS Tools 2.8.3.762</div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="daisychain.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="_glossary.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>