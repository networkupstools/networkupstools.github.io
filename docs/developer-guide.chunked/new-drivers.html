<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. Creating a new driver to support another device</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="Network UPS Tools Developer Guide" /><link rel="up" href="index.html" title="Network UPS Tools Developer Guide" /><link rel="prev" href="developers.html" title="4. Information for developers" /><link rel="next" href="sock-protocol.html" title="6. Driver/server socket protocol" /><meta xmlns="" name="format-detection" content="telephone=no" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="developers.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="sock-protocol.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="new-drivers"></a>5. Creating a new driver to support another device</h2></div></div></div><p>This chapter will present the process of creating a new driver to support
another device.</p><p>Since NUT already supports many major power device protocols through
several generic drivers (<code class="literal">genericups</code>, <code class="literal">usbhid-ups</code>, <code class="literal">snmp-ups</code>, <code class="literal">blazer_*</code>
and <code class="literal">nutdrv_qx</code>), creation of new drivers has become rare.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>We have yet to unify modbus drivers under same umbrella like <code class="literal">nutdrv_qx</code>
covering the Megatec Qx protocol family.</p></div><p>So most of the time, this process will be limited to completing one of these
generic drivers.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_smart_vs_contact_closure"></a>5.1. Smart vs. Contact-closure</h3></div></div></div><p>If your UPS only does contact closure readings over an RS-232 serial port, then
go straight to the <a class="link" href="new-drivers.html#contact-closure" title="5.22. Contact closure hardware information">Contact closure hardware</a> chapter for
information on adding support.  It’s a lot easier to add a few lines to a
header file than it is to create a whole new driver.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_serial_vs_usb_vs_snmp_and_more"></a>5.2. Serial vs. USB vs. SNMP and more</h3></div></div></div><p>If your UPS connects to your computer via a USB port, then it most likely
appears as a USB HID device (this is the simplest way for the vendor to write
a Windows control program for it). What comes next depends on whether the
vendor implemented the HID PDC (Power Device Class) specification, or simply
used the HID protocol to transport serial data to the UPS microcontroller.</p><p>A rough heuristic is to check the length of the HID Descriptor length
(<code class="literal">wDescriptorLength</code> in <code class="literal">lsusb -v</code> output). If it is less than 200 bytes long,
the UPS probably has a glorified USB-to-serial converter built in. Since the
query strings often start with the letter <code class="literal">Q</code>, this family of protocols is
often referred to as <code class="literal">Q*</code> in the NUT documentation. See the
<a class="link" href="new-drivers.html#nutdrv_qx-subdrivers" title="5.25. How to make a new subdriver to support another Q* UPS">Q* UPS</a> chapter for more details.</p><p>Otherwise, if the HID Descriptor is longer, you can go to the
<a class="link" href="new-drivers.html#hid-subdrivers" title="5.23. How to make a new subdriver to support another USB/HID UPS">HID subdrivers</a> chapter. You can probably add support for
your device by writing a new subdriver to the existing usbhid-ups driver,
which is easier (and more maintainable) than writing an entire new driver.</p><p>If your USB UPS does not appear to fall into either of these two categories,
feel free to contact the <code class="literal">nut-upsdev</code> mailing list with details of your
device.</p><p>Similarly, if your UPS connects to your computer via an SNMP network
card, you can probably add support for your device by adding a new
subdriver to the existing snmp-ups driver. Instructions are provided
in the <a class="link" href="new-drivers.html#snmp-subdrivers" title="5.24. How to make a new subdriver to support another SNMP device">SNMP subdrivers</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_overall_concept"></a>5.3. Overall concept</h3></div></div></div><p>The basic design of drivers is simple.  <code class="literal">main.c</code> handles most of the work
for you.  You don’t have to worry about arguments, config files, or
anything else like that.  Your only concern is talking to the hardware
and providing data to the outside world.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_skeleton_driver"></a>5.4. Skeleton driver</h3></div></div></div><p>Familiarize yourself with the design of <code class="literal">skel.c</code> in the drivers directory.
It shows a few examples of the functions that <code class="literal">main.c</code> will call to obtain
updated information from the hardware.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_essential_structure"></a>5.5. Essential structure</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsdrv_info_t"></a>upsdrv_info_t</h4></div></div></div><p>This structure tracks several description information about the driver:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>name</strong></span>:    the driver full name, for banner printing and "driver.name" variable.
</li><li class="listitem">
<span class="strong"><strong>version</strong></span>: the driver’s own version. For sub driver information, refer below
              to sub_upsdrv_info. This value has the form "X.YZ", and is
              published by main as "driver.version.internal".
</li><li class="listitem">
<span class="strong"><strong>authors</strong></span>: the driver’s author(s) name. If multiple authors are listed,
              separate them with a newline character so that it can be broken
              up by author if needed.
</li><li class="listitem"><p class="simpara">
<span class="strong"><strong>status</strong></span>:  the driver development status. The following values are allowed:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
DRV_BROKEN: setting this value will cause main to print an error
              and exit. This is only used during conversions of the driver core
              to keep users from using drivers which have not been converted.
              Drivers in this state will be removed from the tree after some
              period if they are not fixed.
</li><li class="listitem">
DRV_EXPERIMENTAL: set this value if your driver is potentially
              broken. This will trigger a warning when it starts so the user
              doesn’t take it for granted.
</li><li class="listitem">
DRV_BETA: this value means that the driver is more stable and
              complete. But it is still not recommended for production systems.
</li><li class="listitem">
DRV_STABLE: the driver is suitable for production systems, but
              not 100 % feature complete.
</li><li class="listitem">
DRV_COMPLETE: this is the gold level! It implies that 100 % of
              the protocol is implemented, and a full QA pass.
</li></ul></div></li><li class="listitem">
<span class="strong"><strong>subdrv_info</strong></span>: array of upsdrv_info_t for sub driver(s) information. For
              example, this is used by usbhid-ups.
</li></ul></div><p>This information is currently used for the startup banner printing and tests.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_essential_functions"></a>5.6. Essential functions</h3></div></div></div><p>For a full current list of functions expected in this context, please see the
<code class="literal">drivers/main.h</code> file in NUT sources.  Some more methods may be required by
driver structure, even if in the common case they have no-op implementations.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsdrv_initups"></a>upsdrv_initups</h4></div></div></div><p>Open the port (<code class="literal">device_path</code>) and do any low-level things that it may need
to start using that port.  If you have to set DTR or RTS on a serial
port, do it here.</p><p>Don’t do any sort of hardware detection here, since you may be going
into upsdrv_shutdown next.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsdrv_initinfo"></a>upsdrv_initinfo</h4></div></div></div><p>Try to detect what kind of UPS is out there, if any, assuming that’s
possible for your hardware.  If there is a way to detect that hardware
and it doesn’t appear to be connected, display an error and exit. This
is the last time your driver is allowed to bail out.</p><p>This is usually a good place to create variables like <code class="literal">ups.mfr</code>,
<code class="literal">ups.model</code>, <code class="literal">ups.serial</code>, determine and declare supported instant
commands (maybe model-dependent, typically for all devices supported
by the driver), and other "one time only" items.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsdrv_updateinfo"></a>upsdrv_updateinfo</h4></div></div></div><p>Poll the hardware, and update any variables that you care about
monitoring.  Use <code class="literal">dstate_setinfo()</code> to store the new values.</p><p>Do at most one pass of the variables.  You MUST return from this
function or upsd will be unable to read data from your driver.  main
will call this function at regular intervals.</p><p>Don’t spent more than a couple of seconds in this function. Typically
five (5) seconds is the maximum time allowed before you risk that the
server declares the driver stale. If your UPS hardware requires a
timeout period of several seconds before it answers, consider returning
from this function after sending a command immediately and read the
answer the next time it is called.</p><p>You must never abort from upsdrv_updateinfo(), even when the UPS doesn’t
seem to be attached anymore. If the connection with the UPS is lost, the
driver should retry to re-establish communication for as long as it is
running. Calling <code class="literal">exit()</code> or any of the <code class="literal">fatal*()</code> functions is specifically
not allowed anymore.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_upsdrv_shutdown"></a>upsdrv_shutdown</h4></div></div></div><p>Do whatever you can to make the UPS power off the load but also return
after the power comes back on.  You may use a different command that
keeps the UPS off if the user has requested that with a configuration
setting.</p><p>You should attempt the UPS shutdown command even if the UPS detection
fails.  If the UPS does not shut down the load, then the user is
vulnerable to a race if the power comes back on during the shutdown
process.</p><p>This method should not directly <code class="literal">exit()</code> the driver program (neither
should it call <code class="literal">fatalx()</code> nor <code class="literal">fatal_with_errno()</code> methods).  It can
<code class="literal">upslogx(LOG_ERR, ...)</code> or <code class="literal">upslog_with_errno(LOG_ERR, ...)</code>, and then
<code class="literal">set_exit_flag(N)</code> if required, using values <code class="literal">EF_EXIT_FAILURE</code> (<code class="literal">-1</code>)
for eventual <code class="literal">exit(EXIT_FAILURE)</code> and <code class="literal">EF_EXIT_SUCCESS</code> (<code class="literal">-2</code>) for
<code class="literal">exit(EXIT_SUCCESS)</code>, which would be handled in the standard driver
loop or in <code class="literal">forceshutdown()</code> method of <code class="literal">main.c</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_data_types"></a>5.7. Data types</h3></div></div></div><p>To be of any use, you must supply data in <code class="literal">ups.status</code>.  That is the
minimum needed to let upsmon do its job.  Whenever possible, you should
also provide anything else that can be monitored by the driver.  Some
obvious things are the manufacturer name and model name, voltage data,
and so on.</p><p>If you can’t figure out some value automatically, use the <code class="literal">ups.conf</code>
options to let the user tell you.  This can be useful when a driver
needs to support many similar hardware models, but can’t probe to see
what is actually attached.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_manipulating_the_data"></a>5.8. Manipulating the data</h3></div></div></div><p>All status data lives in structures that are managed by the dstate
functions.  All access and modifications must happen through those
functions.  Any other changes are forbidden, as they will not pushed out
as updates to things like upsd.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_adding_variables"></a>Adding variables</h4></div></div></div><pre class="literallayout">dstate_setinfo("ups.model", "Mega-Zapper 1500");</pre><p>Many of these functions take format strings, so you can build the new
values right there:</p><pre class="literallayout">dstate_setinfo("ups.model", "Mega-Zapper %d", rating);</pre><p>In a few cases you can use a formatting string coming from a mapping
table or constructed during run-time.  This is generally not safe (due
to references into the stack when handling the variable argument list),
and modern compilers warn against doing so.  While it is possible to
quiesce the warnings with pragmas, it is better to play safe with the
"dynamic" versions of methods provided by NUT — they allow to combine
both compile-time checks of expected formatting string vs. types of data
in the method arguments, and run-time equivalence of the actual dynamic
formatting string to those expectations.  In this case, you would use
<code class="literal">dstate_setinfo_dynamic()</code> with a coding pattern similar to the following:</p><pre class="literallayout">char *fmt = "Mega-Zapper %d";
dstate_setinfo_dynamic("ups.model", fmt, "%d", rating);</pre><p>Please note that <code class="literal">ups.alarm</code> should no longer be manually set, but rather
the appropriate alarm functions should be used instead. For more details,
see below in the <code class="literal">UPS alarms</code> section.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_setting_flags"></a>Setting flags</h4></div></div></div><p>Some variables have special properties.  They can be writable, and some
are strings.  The <code class="literal">ST_FLAG_*</code> values can be used to tell upsd more about
what it can do.</p><pre class="literallayout">dstate_setflags("input.transfer.high", ST_FLAG_RW);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_status_data"></a>Status data</h4></div></div></div><p>UPS status flags like on line (OL) and on battery (OB) live in
ups.status.  Don’t manipulate this by hand.  There are functions which
will do this for you.</p><pre class="literallayout">status_init()   -- before doing anything else (clear internal buffers,
                   etc.)</pre><pre class="literallayout">status_get(val) -- optionally check if a status word had been set
                   since the most-recent status_init()</pre><pre class="literallayout">status_set(val) -- add a status word (OB, OL, etc)</pre><pre class="literallayout">status_commit() -- push out the update</pre><p>Possible values for status_set:</p><pre class="literallayout">OL      -- On line (mains is present)
OB      -- On battery (mains is not present)
LB      -- Low battery
HB      -- High battery
RB      -- The battery needs to be replaced
CHRG    -- The battery is charging
DISCHRG -- The battery is discharging (inverter is providing load power)
BYPASS  -- UPS bypass circuit is active -- no battery protection is available
CAL     -- UPS is currently performing runtime calibration (on battery)
OFF     -- UPS is offline and is not supplying power to the load
OVER    -- UPS is overloaded
TRIM    -- UPS is trimming incoming voltage (called "buck" in some hardware)
BOOST   -- UPS is boosting incoming voltage
FSD     -- Forced Shutdown (restricted use, see the note below)</pre><p><code class="literal">ALARM</code> should no longer be raised through the UPS status.
An <code class="literal">ALARM</code> value will be added internally (typically as first in the list)
if an alarm was set and committed through the appropriate alarm functions.
For more details, see below in the <code class="literal">UPS alarms</code> section.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The NUT data server <code class="literal">upsd</code> initially sets <code class="literal">ups.status</code> to a value of <code class="literal">WAIT</code>
when first connecting to a NUT driver using the socket protocol, and issues
a <code class="literal">DUMPALL</code> command.  This temporary <code class="literal">WAIT</code> status gets overwritten whenever
any relevant information update from a driver arrives, typically either as
part of its own initialization, or of the regular polling loop.</p><p>This may seem roughly similar to a "Data stale" situation; however, the NUT
clients like <code class="literal">upsmon</code> should not infer anything for shutdown decisions from
this lack of initial connection, like they do for <span class="strong"><strong>loss</strong></span> of connection during
a known critical power situation.</p><p>For some more detailed insight into the NUT driver’s current state machine
position (as reported by the driver after communications are established),
see also <code class="literal">driver.state</code>.</p></div><p>Anything else will not be recognized by the usual clients expecting a
particular NUT standard release.  New tokens may appear over time, but
driver developers should coordinate with the nut-upsdev list before creating
something new, since there will be duplication and ugliness otherwise.
It is possible that eventually, due to hardware and software design evolution,
some concepts would be superseded by others.  Fundamental meanings of the
flags listed above should not change (but these flags may become no longer
issued by the current NUT drivers; then may still be used e.g. in forks or
older packaged builds).</p><p>Clients however MUST accept any space-separated tokens in <code class="literal">ups.status</code>
without error or crash, and MUST treat those defined above with the
ascribed meanings, but MAY ignore unidentified tokens (quietly by default,
or acknowledge the skip with a debug log message).</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
upsd injects <code class="literal">FSD</code> by itself following that command by a primary upsmon
process.  Drivers must not set that value, apart from specific cases (see
below).
</li><li class="listitem">
As an exception, drivers may set <code class="literal">FSD</code> when an imminent shutdown has been
detected. In this case, the "on battery + low battery" condition should not be
met. Otherwise, setting status to <code class="literal">OB LB</code> should be preferred.
</li><li class="listitem">
the <code class="literal">OL</code> and <code class="literal">OB</code> flags are an indication of the input line status only.
</li><li class="listitem">
the <code class="literal">CHRG</code> and <code class="literal">DISCHRG</code> flags are being replaced with
<code class="literal">battery.charger.status</code>.  See the <a class="ulink" href="../user-manual.chunked/index.html#nut-names" target="_top">NUT command and variable naming scheme</a> for more information.
</li></ul></div></div><p>Similar functionality can be supported for <code class="literal">experimental.ups.mode.buzzwords</code>,
where it is tracked dynamically (e.g. due to ECO/ESS/HE/Smart or similar
marketing buzzword modes supported by the device), using the following
methods in the processing loop:</p><pre class="literallayout">buzzmode_init()   -- before doing anything else (clear internal buffers,
                     etc.)</pre><pre class="literallayout">buzzmode_get(val) -- optionally check if an UPS mode buzzword had been
                     set since the most-recent buzzmode_init()</pre><pre class="literallayout">buzzmode_set(val) -- add an UPS mode buzzword (vendor:eaton:ECO, etc.)</pre><pre class="literallayout">buzzmode_commit() -- push out the update</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_ups_alarms"></a>5.9. UPS alarms</h3></div></div></div><p>These work like <code class="literal">ups.status</code>, and have three special functions which you
must use to manage them.</p><pre class="literallayout">alarm_init() -- before doing anything else</pre><pre class="literallayout">alarm_set() -- add an alarm word</pre><pre class="literallayout">alarm_commit() -- push the value into ups.alarm</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The ALARM flag in <code class="literal">ups.status</code> is automatically set whenever you use
<code class="literal">alarm_set()</code>.  To remove that flag from <code class="literal">ups.status</code>, call <code class="literal">alarm_init()</code>
and <code class="literal">alarm_commit()</code> without calling <code class="literal">alarm_set()</code> in the middle.</p></div><p>You should never try to set or unset the ALARM flag manually.</p><p>If you use UPS alarms, the call to <code class="literal">status_commit()</code> should be <span class="strong"><strong>after</strong></span>
<code class="literal">alarm_commit()</code>, otherwise there will be a delay in setting the ALARM
flag in <code class="literal">ups.status</code>.</p><p>There is no official list of alarm keywords as of this writing, so don’t
use these functions until you check with the upsdev list.</p><p>Also refer to the <a class="link" href="daisychain.html" title="B. NUT daisychain support notes">NUT daisychain support notes</a> chapter
of the user manual and developer guide for information related to alarms
handling in daisychain mode.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_staleness_control"></a>5.10. Staleness control</h3></div></div></div><p>If you’re not talking to a polled UPS, then you must ensure that it
is still out there and is alive before calling dstate_dataok().  Even
if nothing is changing, you should still "ping" it or do something
else to ensure that it is really available.  If the attempts to
contact the UPS fail, you must call dstate_datastale() to inform the
server and clients.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
dstate_dataok()
</p><p class="simpara">You must call this if polls are succeeding.  A good place to call this
is the bottom of upsdrv_updateinfo().</p></li><li class="listitem"><p class="simpara">
dstate_datastale()
</p><p class="simpara">You must call this if your status is unusable.  A good technique is
to call this before exiting prematurely from upsdrv_updateinfo().</p></li></ul></div><p>Don’t hide calls to these functions deep inside helper functions.  It is
very hard to find the origin of staleness warnings, if you call these from
various places in your code.  Basically, don’t call them from any other
function than from within upsdrv_updateinfo().  There is no need to call
either of these regularly as was stated in previous versions of this
document (that requirement has long gone).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_serial_port_handling"></a>5.11. Serial port handling</h3></div></div></div><p>Drivers which use serial port functions should include serial.h and use
these functions (and cross-platform data types) whenever possible:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
TYPE_FD
</p><p class="simpara">Cross-platform data type to represent a serial-port connection.</p></li><li class="listitem"><p class="simpara">
ERROR_FD_SER
</p><p class="simpara">Macro value representing an invalid serial-port connection.</p></li><li class="listitem"><p class="simpara">
VALID_FD_SER(TYPE_FD_SER fd)
</p><p class="simpara">This macro evaluates to <code class="literal">true</code> if <code class="literal">fd</code> currently has a "valid" value
(e.g. represents a connected device). You should invalidate the <code class="literal">fd</code>
when you initialize the variable or close the connection, by assigning
<code class="literal">fd = ERROR_FD</code>.</p></li><li class="listitem"><p class="simpara">
INVALID_FD_SER(TYPE_FD_SER fd)
</p><p class="simpara">This macro evaluates to <code class="literal">true</code> if <code class="literal">fd</code> does not currently have a
"valid" value.</p></li><li class="listitem"><p class="simpara">
TYPE_FD_SER ser_open(const char *port)
</p><p class="simpara">This opens the port and locks it if possible, using one of fcntl, lockf,
or uu_lock depending on what may be available.  If something fails, it
calls fatal for you.  If it succeeds, it always returns the fd that was
opened.</p></li><li class="listitem"><p class="simpara">
TYPE_FD_SER ser_open_nf(const char *port)
</p><p class="simpara">This is a non-fatal version of ser_open(), that does not call fatal if
something fails.</p></li><li class="listitem"><p class="simpara">
int ser_set_speed(TYPE_FD_SER fd, const char *port, speed_t speed)
</p><p class="simpara">This sets the speed of the port and also does some basic configuring
with tcgetattr and tcsetattr.  If you have a special serial
configuration (other than 8N1), then this may not be what you want.</p><p class="simpara">The port name is provided again here so failures in tcgetattr() provide
a useful error message.  This is the only place that will generate a
message if someone passes a non-serial port /dev entry to your driver,
so it needs the extra detail.</p></li><li class="listitem"><p class="simpara">
int ser_set_speed_nf(TYPE_FD_SER fd, const char *port, speed_t speed)
</p><p class="simpara">This is a non-fatal version of ser_set_speed(), that does not call fatal
if something fails.</p></li><li class="listitem">
int ser_set_dtr(TYPE_FD_SER fd, int state)
</li><li class="listitem"><p class="simpara">
int ser_set_rts(TYPE_FD_SER fd, int state)
</p><p class="simpara">These functions can be used to set the modem control lines to provide
cable power on the RS232 interface. Use state = 0 to set the line to 0
and any other value to set it to 1.</p></li><li class="listitem">
int ser_get_dsr(TYPE_FD_SER fd)
</li><li class="listitem">
int ser_get_cts(TYPE_FD_SER fd)
</li><li class="listitem"><p class="simpara">
int ser_get_dcd(TYPE_FD_SER fd)
</p><p class="simpara">These functions read the state of the modem control lines. They will
return 0 if the line is logic 0 and a non-zero value if the line is
logic 1.</p></li><li class="listitem"><p class="simpara">
int ser_close(TYPE_FD_SER fd, const char *port)
</p><p class="simpara">This function unlocks the port if possible and closes the fd.  You
should call this in your upsdrv_cleanup handler.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_send_char(TYPE_FD_SER fd, unsigned char ch)
</p><p class="simpara">This attempts to write one character and returns the return value from
write.  You could call write directly, but using this function allows
for future error handling in one place.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_send_pace(TYPE_FD_SER fd, useconds_t d_usec,
                                const char *fmt, …)
</p><p class="simpara">If you need to send a formatted buffer with an intercharacter delay, use
this function.  There are a number of UPS controllers which can’t take
commands at the full speed that would normally be possible at a given
bit rate.  Adding a small delay usually turns a flaky UPS into a solid
one.</p><p class="simpara">The return value is the number of characters that was sent to the port,
or <span class="emphasis"><em>-1</em></span> if something failed.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_send(TYPE_FD_SER fd, const char *fmt, …)
</p><p class="simpara">Like ser_send_pace, but without a delay.  Only use this if you’re sure
that your UPS can handle characters at the full line rate.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_send_buf(TYPE_FD_SER fd, const void *buf, size_t buflen)
</p><p class="simpara">This sends a raw buffer to the fd.  It is typically used for binary
transmissions.  It returns the results of the call to write.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_send_buf_pace(TYPE_FD_SER fd, useconds_t d_usec,
                                    const void *buf, size_t buflen)
</p><p class="simpara">This is just ser_send_buf with an intercharacter delay.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_get_char(TYPE_FD_SER fd, void *ch, time_t d_sec, useconds_t d_usec)
</p><p class="simpara">This will wait up to d_sec seconds + d_usec microseconds for one
character to arrive, storing it at ch.  It returns 1 on success, -1
if something fails and 0 on a timeout.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The delay value must not be too large, or your driver will not get
back to the usual idle loop in main in time to answer the PINGs from
upsd.  That will cause an oscillation between staleness and normal
behavior.</p></div></li><li class="listitem"><p class="simpara">
ssize_t ser_get_buf(TYPE_FD_SER fd, void *buf, size_t buflen,
                              time_t d_sec, useconds_t d_usec)
</p><p class="simpara">Like ser_get_char, but this one reads up to buflen bytes storing all of
them in buf.  The buffer is zeroed regardless of success or failure.  It
returns the number of bytes read, -1 on failure and 0 on a timeout.</p><p class="simpara">This is essentially a single read() function with a timeout.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_get_buf_len(TYPE_FD_SER fd, void *buf, size_t buflen,
                                  time_t d_sec, useconds_t d_usec)
</p><p class="simpara">Like ser_get_buf, but this one waits for buflen bytes to arrive,
storing all of them in buf.  The buffer is zeroed regardless of success
or failure.  It returns the number of bytes read, -1 on failure
and 0 on a timeout.</p><p class="simpara">This should only be used for binary reads.  See ser_get_line for
protocols that are terminated by characters like CR or LF.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_get_line(TYPE_FD_SER fd, void *buf, size_t buflen,
                               char endchar, const char *ignset,
                               time_t d_sec, useconds_t d_usec)
</p><p class="simpara">This is the reading function you should use if your UPS tends to send
responses like "OK\r" or "1234\n".  It reads up to buflen bytes and
stores them in buf, but it will return immediately if it encounters
endchar.  The endchar will not be stored in the buffer.  It will also
return if it manages to collect a full buffer before reaching the
endchar.  It returns the number of bytes stored in the buffer, -1 on
failure and 0 on a timeout.</p><p class="simpara">If the character matches the ignset with strchr(), it will not be added
to the buffer.  If you don’t need to ignore any characters, just pass it
an empty string — <code class="literal">""</code>.</p><p class="simpara">The buffer is always cleared and is always <code class="literal">null</code>-terminated.  It does
this by reading at most <code class="literal">(buflen - 1)</code> bytes.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Any other data which is read after the endchar in the serial
buffer will be lost forever.  As a result, you should not use this
unless your UPS uses a polled protocol.</p></div><p class="simpara">Let’s say your endchar is <code class="literal">\n</code> and your UPS sends <code class="literal">"OK\n1234\nabcd\n"</code>.
This function will <code class="literal">read()</code> all of that, find the first <code class="literal">\n</code>, and stop
there.  Your driver will get <code class="literal">"OK"</code>, and the rest is gone forever.</p><p class="simpara">This also means that you should not "pipeline" commands to the UPS.
Send a query, then read the response, then send the next query.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_get_line_alert(TYPE_FD_SER fd, void *buf, size_t buflen,
                                     char endchar, const char *ignset,
                                     const char *alertset,
                                     void handler(char ch),
                                     time_t d_sec, useconds_t d_usec)
</p><p class="simpara">This is just like ser_get_line, but it allows you to specify a set of
alert characters which may be received at any time.  They are not added
to the buffer, and this function will call your handler function,
passing the character as an argument.</p><p class="simpara">Implementation note: this function actually does all of the work, and
ser_get_line is just a wrapper that sets an empty alertset and a NULL
handler.</p></li><li class="listitem"><p class="simpara">
ssize_t ser_flush_in(TYPE_FD_SER fd, const char *ignset, int verbose)
</p><p class="simpara">This function will drain the input buffer.  If verbose is set to a
positive number, then it will announce the characters which have been
read in the syslog.  You should not set verbose unless debugging is
enabled, since it could be very noisy.</p><p class="simpara">This function returns the number of characters which were read, so you
can check for extra bytes by looking for a nonzero return value.  Zero
will also be returned if the read fails for some reason.</p></li><li class="listitem"><p class="simpara">
int ser_flush_io(TYPE_FD_SER fd)
</p><p class="simpara">This function drains both the in- and output buffers. Return zero on
success.</p></li><li class="listitem"><p class="simpara">
void ser_comm_fail(const char *fmt, …)
</p><p class="simpara">Call this whenever your serial communications fail for some reason.  It
takes a format string, so you can use variables and other things to
clarify the error.  This function does built-in rate-limiting so you
can’t spam the syslog.</p><p class="simpara">By default, it will write 10 messages, then it will stop and only write
1 in 100.  This allows the driver to keep calling this function while
the problem persists without filling the logs too quickly.</p><p class="simpara">In the old days, drivers would report a failure once, and then would be
silent until things were fixed again.  Users had to figure out what was
happening by finding that single error message, or by looking at the
repeated complaints from upsd or the clients.</p><p class="simpara">If your UPS frequently fails to acknowledge polls and this is a known
situation, you should make a couple of attempts before calling this
function.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This does not call dstate_datastale.  You still need to do that.</p></div></li><li class="listitem"><p class="simpara">
void ser_comm_good(void)
</p><p class="simpara">This will clear the error counter and write a "re-established" message
to the syslog after communications have been lost.  Your driver should
call this whenever it has successfully contacted the UPS.  A good place
for most drivers is where it calls dstate_dataok.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_usb_port_handling"></a>5.12. USB port handling</h3></div></div></div><p>Drivers which use USB functions should include usb-common.h and use these:</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_structure_and_macro"></a>Structure and macro</h4></div></div></div><p>You should use the usb_device_id_t structure, and the USB_DEVICE macro to
declare the supported devices. This allows the automatic extraction of
USB information, to generate the Hotplug, udev and UPower support files.</p><p>The structure allows to convey <code class="literal">uint16_t</code> values of VendorID and ProductID,
and an optional matching-function callback to interrogate the device in
more detail (constrain known supported firmware versions, OEM brands, etc.)</p><p>For example:</p><pre class="screen">/* SomeVendor name */
#define SOMEVENDOR_VENDORID             0xXXXX

/* USB IDs device table */
static usb_device_id_t sv_usb_device_table [] = {
        /* some models 1 */
        { USB_DEVICE(SOMEVENDOR_VENDORID, 0xYYYY), NULL },

        /* various models */
        { USB_DEVICE(SOMEVENDOR_VENDORID, 0xZZZZ), NULL },
        { USB_DEVICE(SOMEVENDOR_VENDORID, 0xAAAA), NULL },

        /* Terminating entry */
        { 0, 0, NULL }
};</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_function"></a>Function</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
is_usb_device_supported(usb_device_id_t *usb_device_id_list,
                                  USBDevice_t *device)
</p><p class="simpara">Call this in your device opening / matching function. Pass your usb_device_id_t
list structure, and a set of VendorID, DeviceID, as well as Vendor, Product and
Serial strings, possibly also Bus, bcdDevice (device release number) and Device
name on the bus strings, in the USBDevice_t fields describing the specific piece
of hardware you are inspecting.</p><p class="simpara">This function returns one of the following value:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
NOT_SUPPORTED (0),
</li><li class="listitem">
POSSIBLY_SUPPORTED (1, returned when the VendorID is matched,
                  but the DeviceID is unknown),
</li><li class="listitem">
or SUPPORTED (2).
</li></ul></div><p class="simpara">For implementation examples, refer to the various USB drivers, and search for
the above patterns.</p></li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This set of USB helpers is due to expand is the near future…</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_variable_names"></a>5.13. Variable names</h3></div></div></div><p>PLEASE don’t make up new variables and commands just because you can.
The new dstate functions give us the power to create just about
anything, but that is a privilege and not a right.  Imagine the mess
that would happen if every developer decided on their own way to
represent a common status element.</p><p>Check the <a class="link" href="nut-names.html" title="A. NUT command and variable naming scheme">NUT command and variable naming scheme</a> section first to
find the closest fit. If nothing matches, contact the upsdev list, and we’ll
figure it out.</p><p>Patches which introduce unlisted names may be modified or dropped.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="commands"></a>5.14. Message passing support</h3></div></div></div><p>upsd can call drivers to store values in read/write variables and to kick
off instant commands.  This is how you register handlers for those events.</p><p>The driver core (drivers/main.c) has a structure called upsh.  You
should populate it with function pointers in your upsdrv_initinfo()
function.  Right now, there are only two possibilities:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
setvar  = setting UPS variables (SET VAR protocol command)
</li><li class="listitem">
instcmd = instant UPS commands (INSTCMD protocol command)
</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_set"></a>SET</h4></div></div></div><p>If your driver’s function for handling variable set events is called
my_ups_set(), then you’d do this to add the pointer:</p><pre class="literallayout">upsh.setvar = my_ups_set;</pre><p>my_ups_set() will receive two parameters:</p><pre class="literallayout">const char * -- the variable being changed
const char * -- the new value</pre><p>You should return either STAT_SET_HANDLED if your driver recognizes the
command, or STAT_SET_UNKNOWN if it doesn’t.  Other possibilities will be
added at some point in the future.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_instcmd"></a>INSTCMD</h4></div></div></div><p>This works just like the set process, with slightly different values
arriving from the server.</p><pre class="literallayout">upsh.instcmd = my_ups_cmd;</pre><p>Your function will receive two args:</p><pre class="literallayout">const char * -- the command name
const char * -- (reserved)</pre><p>You should return either STAT_INSTCMD_HANDLED or STAT_INSTCMD_UNKNOWN
depending on whether your driver can handle the requested command.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_notes"></a>Notes</h4></div></div></div><p>Use strcasecmp.  The command names arriving from upsd should be treated
without regards to case.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_responses"></a>Responses</h4></div></div></div><p>Drivers will eventually be expected to send responses to commands.
Right now, there is no channel to get these back through upsd to
the client, so this is not implemented.</p><p>This will probably be implemented with a polling scheme in the clients.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_enumerated_types"></a>5.15. Enumerated types</h3></div></div></div><p>If you have a variable that can have several specific values, it is
enumerated.  You should add each one to make it available to the client:</p><pre class="literallayout">dstate_addenum("input.transfer.low", "92");
dstate_addenum("input.transfer.low", "95");
dstate_addenum("input.transfer.low", "99");
dstate_addenum("input.transfer.low", "105");</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_range_values"></a>5.16. Range values</h3></div></div></div><p>If you have a variable that support values comprised in one or more ranges,
you should add each one to make it available to the client:</p><pre class="literallayout">dstate_addrange("input.transfer.low", 90, 95);
dstate_addrange("input.transfer.low", 100, 105);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_writable_strings"></a>5.17. Writable strings</h3></div></div></div><p>Strings that may be changed by the client should have the ST_FLAG_STRING
flag set, and a maximum length (in bytes) set in the auxdata.</p><pre class="literallayout">dstate_setinfo("ups.id", "Big UPS");
dstate_setflags("ups.id", ST_FLAG_STRING | ST_FLAG_RW);
dstate_setaux("ups.id", 8);</pre><p>If the variable is not writable, don’t bother with the flags or the
auxiliary data.  It won’t be used.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_instant_commands_2"></a>5.18. Instant commands</h3></div></div></div><p>If your hardware and driver can support a command, register it.</p><pre class="literallayout">dstate_addcmd("load.on");</pre><p>Don’t forget to define the implementation for such commands in a common
method, and register that your driver has an instant command handler at
all — with a line in <code class="literal">upsdrv_initinfo()</code> like:</p><pre class="literallayout">upsh.instcmd = blazer_instcmd;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_delays_and_ser__functions"></a>5.19. Delays and ser_* functions</h3></div></div></div><p>The new ser_* functions may perform reads faster than the UPS is able to
respond in some cases.  This means that your driver will call select()
and read() numerous times if your UPS responds in bursts.  This also
depends on how fast your system is.</p><p>You should check your driver with <code class="literal">strace</code> or its equivalent on your
system.  If the driver is calling read() multiple times, consider adding
a call to usleep before going into the ser_read_* call.  That will give
it a chance to accumulate so you get the whole thing with one call to
read without looping back for more.</p><p>This is not a request to save CPU time, even though it may do that.  The
important part here is making the strace/ktrace output easier to read.</p><pre class="literallayout">write(4, "Q1\r", 3)                     = 3
nanosleep({0, 300000000}, NULL)         = 0
select(5, [4], NULL, NULL, {3, 0})      = 1 (in [4], left {3, 0})
read(4, "(120.0 084.0 120.0   0 60.0 22.6"..., 64) = 47</pre><p>Without that delay, that turns into a mess of selects and reads.
The select returns almost instantly, and read gets a tiny chunk of the
data.  Add the delay and you get a nice four-line status poll.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_canonical_input_mode_processing"></a>5.20. Canonical input mode processing</h3></div></div></div><p>If your UPS uses "\n" and/or "\r" as endchar, consider the use of
Canonical Input Mode Processing instead of the ser_get_line* functions.</p><p>Using a serial port in this mode means that select() will wait until
a full line is received (or times out). This relieves you from waiting
between sending a command and reading the reply. Another benefit is,
that you no longer have to worry about the case that your UPS sends
"OK\n1234\nabcd\n". This will be broken up cleanly in "OK\n", "1234\n"
and "abcd\n" on consecutive reads, without risk of losing data (which
is an often forgotten side effect of the ser_get_line* functions).</p><p>Currently, an example how this works can be found in the safenet and
upscode2 drivers. The first uses a single "\r" as endchar, while the
latter accepts either "\n", "\n\r" or "\r\n" as line termination. You
can define other termination characters as well, but can’t undefine
"\r" and "\n" (so if you need these as data, this is not for you).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_adding_the_driver_into_the_tree"></a>5.21. Adding the driver into the tree</h3></div></div></div><p>In order to build your new driver, it needs to be added to
<code class="literal">drivers/Makefile.am</code>. At the moment, there are several driver list variables
corresponding to the general protocol of the driver (<code class="literal">SERIAL_DRIVERLIST</code>,
<code class="literal">SNMP_DRIVERLIST</code>, etc.). If your driver does not fit into one of these
categories, please discuss it on the nut-upsdev mailing list.</p><p>There are also <code class="literal">*_SOURCES</code> and optional <code class="literal">*_LDADD</code> variables to list the source
files, and any additional linker flags. If your driver uses the C math
library, be sure to add <code class="literal">-lm</code>, since this flag is not always included by
default on embedded systems.</p><p>When you add a driver to one of these lists, pay attention to the backslash
continuation characters (<code class="literal">\\</code>) at the end of the lines.</p><p>The <code class="literal">automake</code> program converts the <code class="literal">Makefile.am</code> files into <code class="literal">Makefile.in</code>
files to be processed by <code class="literal">./configure</code>. See the discussion in <a class="xref" href="developers.html#building" title="4.16. Building the Code">Section 4.16, “Building the Code”</a>
about automating the rebuild process for these files.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="contact-closure"></a>5.22. Contact closure hardware information</h3></div></div></div><p>This is a collection of notes that apply to contact closure UPS
hardware, specifically those monitored by the genericups driver.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_definitions"></a>Definitions</h4></div></div></div><p>"Contact closure" refers to a situation where one line is connected to
another inside UPS hardware to indicate some sort of situation.  These
can be relays, or some other form of switching electronics.  The generic
idea is that you either have a signal on a line, or you don’t.  Think
binary.</p><p>Usually, the source for a signal is the host PC.  It provides a high
(logic level 1) from one of its outgoing lines, and the UPS returns it
on one or more lines to communicate.  The rest of the time, the UPS
either lets it float or connects it to the ground to indicate a 0.</p><p>Other equipment generates the high and low signals internally, and does
not require cable power.  These signals just appear on the right lines
without any special configuration on the PC side.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_bad_levels"></a>Bad levels</h4></div></div></div><p>Some evil cabling and UPS equipment uses the transmit or receive lines
as their reference points for these signals.  This is not sufficient to
register as a high signal on many serial ports.  If you have problems
reading certain signals on your system, make sure your UPS isn’t trying
to do this.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_signals"></a>Signals</h4></div></div></div><p>Unlike their smarter cousins, this kind of UPS can only give you very
simple yes/no answers.  Due to the limited number of serial port lines
that can be used for this purpose, you typically get two pieces of data:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
"On line" or "on battery"
</li><li class="listitem">
"Battery OK" or "Low battery"
</li></ol></div><p>That’s it.  Some equipment actually swaps the second one for a
notification about whether the battery needs to be replaced, which makes
life interesting for those users.</p><p>Most hardware also supports an outgoing signal from the PC which means
"shut down the load immediately".  This is generally implemented in such
a way that it only works when running on battery.  Most hardware or
cabling will ignore the shutdown signal when running on line power.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_new_genericups_types"></a>New genericups types</h4></div></div></div><p>If none of the existing types in the genericups driver work completely,
make a note of which ones (if any) manage to work partially.  This can
save you some work when creating support for your hardware.</p><p>Use that information to create a list of where the signals from your UPS
appear on the serial port at the PC end, and whether they are active
high or active low.  You also need to know what outgoing lines, if any,
need to be raised in order to supply power to the contacts.  This is
known as cable power.  Finally, if your UPS can shut down the load, that
line must also be identified.</p><p>There are only 4 incoming and 2 outgoing lines, so not many combinations
are left.  The other lines on a typical 9 pin port are transmit,
receive, and the ground.  Anything trying to do a high/low signal on
those three is beyond the scope of the genericups driver.  The only
exception is an outgoing BREAK, which we already support.</p><p>When editing the genericups.h, the values have the following meanings:</p><p>Outgoing lines:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
line_norm = what to set to make the line "normal" — i.e. cable power
</li><li class="listitem">
line_sd   = what to set to make the UPS shut down the load
</li></ul></div><p>Incoming lines:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
line_ol     = flag that appears for on line / on battery
</li><li class="listitem">
val_ol      = value of that flag when the UPS is on battery
</li><li class="listitem">
line_bl     = flag that appears for low battery / battery OK
</li><li class="listitem">
val_bl      = value of that flag when the battery is low
</li><li class="listitem">
line_rb     = flag that appears for battery health
</li><li class="listitem">
val_rb      = value of that flag when the battery needs a replacement
</li><li class="listitem">
line_bypass = flag that appears for battery bypass / battery protection active
</li><li class="listitem">
val_bypass  = value of that flag when the battery is bypassed / missing
</li></ul></div><p>This may seem a bit confusing to have two variables per value that
we want to read, but here’s how it works.  If you set line_ol to
TIOCM_RNG, then the value of TIOCM_RNG (0x080 on my box) will be anded
with the value of the serial port whenever a poll occurs.  If that flag
exists, then the result of the and will be 0x80.  If it does not exist,
the result will be 0.</p><p>So, if line_ol = foo, then val_ol can only be foo or 0.</p><p>As a general case, if <span class="emphasis"><em>line_ol == val_ol</em></span>, then the value you’re reading
is active high.  Otherwise, it’s active low.  Check out the guts of
upsdrv_updateinfo() to see how it really works.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_custom_definitions"></a>Custom definitions</h4></div></div></div><p>Late in the 1.3 cycle, a feature was merged which allows you to create
custom monitoring settings without editing the model table.  Just set
upstype to something close, then use settings in ups.conf to adjust the
rest.  See the <a class="ulink" href="../man/genericups.html" target="_top">genericups(8)</a> man page for more
details.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="hid-subdrivers"></a>5.23. How to make a new subdriver to support another USB/HID UPS</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_overall_concept_2"></a>Overall concept</h4></div></div></div><p>USB (Universal Serial Port) devices can be divided into several
different classes (audio, imaging, mass storage etc). Almost all UPS
devices belong to the "HID" class, which means "Human Interface
Device", and also includes things like keyboards and mice. What HID
devices have in common is a particular (and very flexible) interface
for reading and writing information (such as X/Y coordinates and
button states, in the case of a mouse, or voltages and status information,
in the case of a UPS).</p><p>The NUT "usbhid-ups" driver is a meta-driver that handles all HID UPS
devices. It consists of a core driver that handles most of the work of
talking to the USB hardware, and several sub-drivers to handle
specific UPS manufacturers (MGE, APC, and Belkin are currently
supported).  Adding support for a new HID UPS device is easy, because
it requires only the creation of a new sub-driver.</p><p>There are a few USB UPS devices that are not true HID devices. These
devices typically implement some version of the manufacturer’s serial
protocol over USB (which is a really dumb idea, by the way). An
example is the original Tripplite USB interface (USB idProduct = 0001). Its HID
descriptor is only 52 bytes long (compared to several hundred bytes for a true
PDC HID UPS).  Such devices are <span class="strong"><strong>not</strong></span> supported by the usbhid-ups driver, and
are not covered in this document. If you need to add support for such a device,
read new-drivers.txt and see the "tripplite_usb" driver for inspiration.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_hid_usage_tree"></a>HID Usage Tree</h4></div></div></div><p>From the point of view of writing a HID subdriver, a HID device
consists of a bunch of variables.  Some variables (such as the current
input voltage) are read-only, whereas other variables (such as the
beeper enabled/disabled/muted status) can be read and written. These
variables are usually grouped together and arranged in a hierarchical
tree shape, similar to directories in a file system. This tree is
called the "usage" tree. For example, here is part of the usage tree
for a typical APC device. Variable components are separated by <code class="literal">.</code>.
Typical values for each variable are also shown for illustrative
purposes.</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="35%"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.Battery.Voltage</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>11.4 V</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.Battery.ConfigVoltage</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>12 V</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.Input.Voltage</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>117 V</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.Input.ConfigVoltage</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>120 V</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.AudibleAlarmControl</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2 (=enabled)</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.PresentStatus.Charging</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>1 (=yes)</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>UPS.PresentStatus.Discharging</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0 (=no)</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>UPS.PresentStatus.ACPresent</p></td><td style="" align="left" valign="top"><p>1 (=yes)</p></td></tr></tbody></table></div><p>As you can see, variables that describe the battery status might be
grouped together under "Battery", variables that describe the input
power might be grouped together under "Input", and variables that
describe the current UPS status might be grouped together under
"PresentStatus". All of these variables are grouped together under
"UPS".</p><p>This hierarchical organization of data has the advantage of being very
flexible; for example, if some device has more than one battery, then
similar information about each battery could be grouped under
"Battery1", "Battery2" and so forth. If your UPS can also be used as a
toaster, then information about the toaster function might be grouped
under "Toaster", rather than "UPS".</p><p>However, the disadvantage is that each manufacturer will have their
own idea about how the usage tree should be organized, and usbhid-ups
needs to know about all of them. This is why manufacturer specific
subdrivers are needed.</p><p>To make matters more complicated, usage tree components (such as
"UPS", "Battery", or "Voltage") are internally represented not as
strings, but as numbers (called "usages" in HID terminology). These
numbers are defined in the "HID Usage Tables", available from
<a class="ulink" href="http://www.usb.org/developers/hidpage/" target="_top">http://www.usb.org/developers/hidpage/</a>.  The standard usages for UPS
devices are defined in a document called "Usage Tables for HID Power
Devices" (the Power Device Class [PDC] specification).</p><p>For example:</p><pre class="screen"> 0x00840010 = UPS
 0x00840012 = Battery
 0x00840030 = Voltage
 0x00840040 = ConfigVoltage
 0x0084001a = Input
 0x0084005a = AudibleAlarmControl
 0x00840002 = PresentStatus
 0x00850044 = Charging
 0x00850045 = Discharging
 0x008500d0 = ACPresent</pre><p>Thus, the above usage tree is internally represented as:</p><pre class="screen"> 00840010.00840012.00840030
 00840010.00840012.00840040
 00840010.0084001a.00840030
 00840010.0084001a.00840040
 00840010.0084005a
 00840010.00840002.00850044
 00840010.00840002.00850045
 00840010.00840002.008500d0</pre><p>To make matters worse, most manufacturers define their own additional
usages, even in cases where standard usages could have been used. For
example Belkin defines <code class="literal">00860040</code> = <code class="literal">ConfigVoltage</code> (which is incidentally
a violation of the USB PDC specification, as <code class="literal">00860040</code> is reserved for
future use).</p><p>Thus, subdrivers generally need to provide:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
manufacturer-specific usage definitions,
</li><li class="listitem">
a mapping of HID variables to NUT variables.
</li></ul></div><p>Moreover, subdrivers might have to provide additional functionality,
such as custom implementations of specific instant commands (<code class="literal">load.off</code>,
<code class="literal">shutdown.restart</code>), and conversions of manufacturer specific data
formats.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_usage_macros_in_drivers_hidtypes_h"></a>Usage macros in drivers/hidtypes.h</h4></div></div></div><p>The <code class="literal">drivers/hidtypes.h</code> header provides a number of macro names
for entries in the standard usage tables for Power Device
<code class="literal">USAGE_POW_&lt;SOMETHING&gt;</code> and Battery System <code class="literal">USAGE_BAT_&lt;SOMETHING&gt;</code>
data pages.</p><p>If NUT codebase would ever need to refresh those macros, here is
some background information (based on NUT issue #1189 and PR #1290):</p><p>These data were parsed from (a very slightly updated version of)
<a class="ulink" href="https://github.com/abend0c1/hidrdd/blob/master/rd.conf" target="_top">https://github.com/abend0c1/hidrdd/blob/master/rd.conf</a> file, which
incorporates the complete USB-IF usage definitions for Power Device
and Battery System pages (among many others), so we didn’t have to
extract the names and values from the USB-IF standards documents
(did check it all by eye though).</p><p>The file was processed with the following chain of commands:</p><pre class="screen">:; grep -e '^0084' -e '^0085' rd.conf \
   | sed 's/,.*$//;s/ *$//' \
   | sed 's/ /_/g;s/_/ /' \
   | tr '[:lower:]' '[:upper:]' \
   | sed 's/\(0085.... \)/\1USAGE_BAT_/;s/\(0084.... \)/\1USAGE_POW_/;s/\([A-Z_]*\)_PAGE/PAGE_\1/' \
   | awk '{print "#define "$2" 0x"$1}'</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_writing_a_subdriver"></a>Writing a subdriver</h4></div></div></div><p>In preparation for writing a subdriver for a device that is currently
unsupported, run usbhid-ups with the following command line:</p><pre class="literallayout">drivers/usbhid-ups -DD -u root -x explore -x vendorid=XXXX \
        -x port=auto -s ups</pre><p>(substitute your device’s 4-digit VendorID instead of "XXXX").
This will produce a bunch of debugging information, including a number
of lines starting with "Path:" that describe the device’s usage tree.
This information forms the initial basis for a new subdriver.</p><p>You should save this information to a file, e.g.:</p><pre class="literallayout">drivers/usbhid-ups -DD -u root -x explore -x vendorid=XXXX \
        -x port=auto -s ups -d1 2&gt;&amp;1 | tee /tmp/info</pre><p>You can now create an initial "stub" subdriver for your device by using
helper script <code class="literal">scripts/subdriver/gen-usbhid-subdriver.sh</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This only creates a driver code "stub" which needs to be further
customized to be actually useful (see "Customization" below).</p></div><p>Use the script as follows:</p><pre class="literallayout">scripts/subdriver/gen-usbhid-subdriver.sh &lt; /tmp/info</pre><p>where <code class="literal">/tmp/info</code> is the file where you previously saved the debugging
information.</p><p>This script prompts you for a name for the subdriver; use only letters
and digits, and use natural capitalization such as "Belkin" (not
"belkin" or "BELKIN"). The script may prompt you for additional
information.</p><p>You should put the generated files into the drivers/ subdirectory, and
update <code class="literal">usbhid-ups.c</code> by adding the appropriate <code class="literal">#include</code> line and by
updating the definition of <code class="literal">subdriver_list</code> in <code class="literal">usbhid-ups.c</code>. You must
also add the subdriver to USBHID_UPS_SUBDRIVERS in <code class="literal">drivers/Makefile.am</code>
and call <code class="literal">autoreconf</code> and/or <code class="literal">./configure</code> from the top-level NUT directory.
You can then recompile <code class="literal">usbhid-ups</code>, and start experimenting with the new
subdriver.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_updating_a_subdriver"></a>Updating a subdriver</h4></div></div></div><p>You may have a device from vendor (and maybe model) whose support <code class="literal">usbhid-ups</code>
already claims. However, you may feel that the driver does not represent all
data points that your device serves. This may be possible, as vendors tend to
use the same identifiers for unrelated products, as well as produce revisions
of devices with same marketed name but different internals (due to chip and
other components availability, cost optimization, etc.) Even without sinister
implications, UPS firmwares evolve and so bugs and features can get added,
fixed and removed over time with truly the same hardware being involved.</p><p>In this case you should follow the same instructions as above for "Writing
a subdriver", but specify the same subdriver name as the one which supports
your device family already.</p><p>Then compare the generated source file with the one already committed to NUT
codebase, paying close attention to <code class="literal">..._hid2nut[]</code> table which maps "usage"
names to NUT data points. There may be several "usage" values served by
different device models or firmware versions, that provide same information
for a NUT data point, such as <code class="literal">input.voltage</code>. For the <code class="literal">hid2nut</code> mapping
tables, first hit wins (so you may e.g. prefer to check values with better
precision first).</p><p>Using a GUI tool with partial-line difference matching and highlighting,
such as Meld or WinMerge, is recommended for this endeavour.</p><p>Alternatively, since NUT v2.8.5, the <code class="literal">usbhid-ups</code> driver initialization
debug log should clarify which values were parsed from the device report
descriptor, but were not looked at when walking the subdriver mapping table.
Some of these items may be due to the device reporting same HID Path with
different Type values (e.g. as an <span class="emphasis"><em>Input</em></span> and as a <span class="emphasis"><em>Feature</em></span>) with the
driver only using one of those; in other cases truly new mappings can be
discovered.</p><p>For new data points in <code class="literal">hid2nut</code> tables be sure to not invent new names,
but use standard ones from <code class="literal">docs/nut-names.txt</code> file. Temporarily, the
<code class="literal">experimental.*</code> or <code class="literal">unmapped.*</code> namespaces may be used.
If you need to standardize a name for some concept not addressed yet,
please do so via nut-upsdev mailing list discussion.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>For new devices (or firmwares) please also anticipate that a wrong
subdriver can get used by default, and a better one may already exist
(perhaps because a vendor matched in the older NUT code by name introduced
new device models with different dialects) — in this case, please focus
on <code class="literal">claim</code> methods to ensure that the new devices get handled by the better
subdriver.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_customization"></a>Customization</h4></div></div></div><p>The initially generated subdriver code is only a stub,
and will not implement any useful functionality (in particular, it
will be unable to shut down the UPS). In the beginning, it simply
attempts to monitor some UPS variables. To make this driver useful,
you must examine the NUT variables of the form "unmapped.*" in the
hid_info_t data structure, and map them to actual NUT variables and
instant commands. There are currently no step-by-step instructions for
how to do this. Please look at the files to see how the currently implemented
subdrivers are written:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
apc-hid.c/h
</li><li class="listitem">
belkin-hid.c/h
</li><li class="listitem">
cps-hid.c/h
</li><li class="listitem">
explore-hid.c/h
</li><li class="listitem">
libhid.c/h
</li><li class="listitem">
liebert-hid.c/h
</li><li class="listitem">
mge-hid.c/h
</li><li class="listitem">
powercom-hid.c/h
</li><li class="listitem">
tripplite-hid.c/h
</li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>To test existing data points (including those not yet translated
to standard NUT mappings conforming to <a class="link" href="nut-names.html" title="A. NUT command and variable naming scheme">NUT command and variable naming scheme</a>), you can use custom drivers built after you
<code class="literal">./configure --with-unmapped-data-points</code>.
Production driver builds must not include any non-standard names.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_fixing_report_descriptors"></a>Fixing report descriptors</h4></div></div></div><p>It is a fact of life that fellow developers make mistakes, and firmware
authors do too. In some cases there are inconsistencies about bytes seen
on the wire vs. their logical values, such value range and signedness if
interpreting them according to standard.</p><p>NUT drivers now include a way to detect and fix up known issues in such
flawed USB report descriptors, side-stepping the standard similarly where
deemed needed. A pointer to such hook method is part of the <code class="literal">subdriver_t</code>
structure detailing each <code class="literal">usbhid-ups</code> subdriver nuances, defaulting to
a <code class="literal">fix_report_desc()</code> trivial implementation.</p><p>For some practical examples, see e.g. <code class="literal">apc_fix_report_desc()</code> method in the
<code class="literal">drivers/apc-hid.c</code> file, and <code class="literal">cps_fix_report_desc()</code> in <code class="literal">drivers/cps-hid.c</code>
file.</p><p>Finally note that such fix-ups may be not applicable to all devices or
firmware versions for what they assume their target audience is. If you
suspect that the fix-up method is actually causing problems, you can quickly
disable it with <code class="literal">disable_fix_report_desc</code> driver option for <code class="literal">usbhid-ups</code>.
If the problem does dissipate, please find a way to identify your "fixed"
hardware/firmware vs. those models where existing fix-up method should be
applied, and post a pull request so the NUT driver would handle both cases.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_investigating_report_descriptors"></a>Investigating report descriptors</h4></div></div></div><p>Beside looking for problems with report descriptor processing in NUT code,
it is important to make sure what data the device actually serves on the
wire, and if it is logically consistent with the protocol requirements.</p><p>While here, keep in mind that USB protocol on the wire has a specified
order of bytes involved, while processing on your computer may lay them
out differently due to bitness and endianness of the current binary build.
General NUT codebase (<code class="literal">libhid.c</code>, <code class="literal">hidparser.c</code>) aims to abstract this,
so application code like drivers can deal with their native numeric data
types, but when troubleshooting, do not rule out possibility of flaws
there as well. And certainly do not code any assumptions about ordered
multiple-byte ranges in a protocol buffer.</p><p>For a deep dive into the byte stream, you will need additional tools:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
get/build/install <a class="ulink" href="https://regina-rexx.sourceforge.io" target="_top">regina-rexx</a>
</li><li class="listitem">
get/install <a class="ulink" href="https://github.com/abend0c1/hidrdd" target="_top">HIDRDD</a> (uses REXX
  as the interpreter)
</li></ul></div><p>Typical troubleshooting of suspected firmware/protocol issues goes like this:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Turn the NUT <code class="literal">usbhid-ups</code> driver debug verbosity level up to 5 (or more)
  and restart the driver, so it would record the HEX dump of report descriptor
</li><li class="listitem">
Look for reports from the driver of any problems it has already detected
  and possibly amended (LogMin/LogMax, report descriptor fix-ups)
</li><li class="listitem">
Extract the HEX dump of the report descriptor from USB driver output from
  the first step above, and run it through HIDRDD (and/or REXX directly,
  per example below).
</li><li class="listitem">
Look at the HIDRDD output, with reference to any documents related to your
  device and the USB/HID power devices class available in NUT documentation,
  e.g. at <a class="ulink" href="https://www.networkupstools.org/ups-protocols.html" target="_top">https://www.networkupstools.org/ups-protocols.html</a>
</li><li class="listitem">
Especially look for inconsistencies in the USB HID report descriptors (RD):
</li><li class="listitem">
between the min/max (logical and physical) values,
</li><li class="listitem">
the sizes of the report fields they apply to,
</li><li class="listitem">
the expected physical values (e.g., supply and output voltages,
    over-voltage/under-voltage transfer points, …)
</li><li class="listitem">
If you’re seeing unexpected values for particular variables, look at the
  raw data that is being sent, decide whether it makes sense in the context
  of the logical and physical min/max values from the report descriptor.
</li><li class="listitem">
Read the NUT code, tracing through how each value gets processed looking
  for where the result deviates from expectations…
</li><li class="listitem">
Think, code, test, rinse, repeat, post a PR :)
</li></ul></div><div class="example"><a id="idm2700"></a><p class="title"><strong>Example 1. Example direct use of REXX</strong></p><div class="example-contents"><p>Example adapted from <a class="ulink" href="https://github.com/networkupstools/nut/issues/2039" target="_top">https://github.com/networkupstools/nut/issues/2039</a></p><p>Run a NUT <code class="literal">usb-hid</code> driver with at least debug verbosity level 3 (<code class="literal">-DDD</code>)
to get a report descriptor dump starting with a line like this:</p><pre class="screen">   3.670755     [D3] Report Descriptor: (909 bytes) =&gt; 05 84 09 04 a1 01 ...</pre><p>…and copy-paste those reported lines as input into <code class="literal">rexx</code> tool, which
would generate a C source file including human-worded description and
a relevant data structure:</p><pre class="screen">:; rexx rd.rex -d --hex 05 84 09 04 a1 01 85 01 09 18 ... 55 b1 02 c0 c0 c0

//--------------------------------------------------------------------------------
// Decoded Application Collection
//--------------------------------------------------------------------------------

/*
05 84        (GLOBAL) USAGE_PAGE         0x0084 Power Device Page
09 04        (LOCAL)  USAGE              0x00840004 UPS (Application Collection)
A1 01        (MAIN)   COLLECTION         0x01 Application (Usage=0x00840004: Page=Power Device Page, Usage=UPS, Type=Application Collection)
85 01          (GLOBAL) REPORT_ID          0x01 (1)
09 18          (LOCAL)  USAGE              0x00840018 Outlet System (Physical Collection)
...
*/

// All structure fields should be byte-aligned...
#pragma pack(push,1)

//--------------------------------------------------------------------------------
// Power Device Page featureReport 01 (Device &lt;-&gt; Host)
//--------------------------------------------------------------------------------

typedef struct
{
  uint8_t  reportId;                                 // Report ID = 0x01 (1)
                                                     // Collection: CA:UPS CP:OutletSystem CP:Outlet
  int8_t   POW_UPSOutletSystemOutletSwitchable;      // Usage 0x0084006C: Switchable, Value =  to
  int8_t   POW_UPSOutletSystemOutletDelayBeforeStartup; // Usage 0x00840056: Delay Before Startup, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletDelayBeforeShutdown; // Usage 0x00840057: Delay Before Shutdown, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletDelayBeforeReboot; // Usage 0x00840055: Delay Before Reboot, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletSwitchable_1;    // Usage 0x0084006C: Switchable, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletDelayBeforeStartup_1; // Usage 0x00840056: Delay Before Startup, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletDelayBeforeShutdown_1; // Usage 0x00840057: Delay Before Shutdown, Value = -1 to 60
  int8_t   POW_UPSOutletSystemOutletDelayBeforeReboot_1; // Usage 0x00840055: Delay Before Reboot, Value = -1 to 60
} featureReport01_t;

#pragma pack(pop)</pre></div></div><br class="example-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_shutting_down_the_ups"></a>Shutting down the UPS</h4></div></div></div><p>It is desirable to support shutting down the UPS. Usually (for
devices that follow the HID Power Device Class specification), this
requires sending the UPS two commands. One for shutting down the UPS
(with an <span class="emphasis"><em>offdelay</em></span>) and one for restarting it (with an <span class="emphasis"><em>ondelay</em></span>),
where offdelay &lt; ondelay. The two NUT commands for which this is
relevant, are <span class="emphasis"><em>shutdown.return</em></span> and <span class="emphasis"><em>shutdown.stayoff</em></span>.</p><p>Since the one-to-one mapping above doesn’t allow sending two HID
commands to the UPS in response to sending one NUT command to the
driver, this is handled by the driver. In order to make this work,
you need to define the following four NUT values:</p><pre class="literallayout">ups.delay.start    (variable, R/W)
ups.delay.shutdown (variable, R/W)
load.off.delay     (command)
load.on.delay      (command)</pre><p>If the UPS supports it, the following variables can be used to show
the countdown to start/shutdown:</p><pre class="literallayout">ups.timer.start    (variable, R/O)
ups.timer.shutdown (variable, R/O)</pre><p>The <code class="literal">load.on</code> and <code class="literal">load.off</code> commands will be defined implicitly by
the driver (using a delay value of <span class="emphasis"><em>0</em></span>). Define these commands
yourself, if your UPS requires a different value to switch on/off
the load without delay.</p><p>Note that the driver expects the <code class="literal">load.off.delay</code> and <code class="literal">load.on.delay</code>
to follow the HID Power Device Class specification, which means that
the <code class="literal">load.on.delay</code> command should NOT switch on the load in the
absence of mains power. If your UPS switches on the load regardless of
the mains status, DO NOT define this command. You probably want to
define the <code class="literal">shutdown.return</code> and/or <code class="literal">shutdown.stayoff</code> commands in
that case. Commands defined in the subdriver will take precedence over
the ones that are composed in the driver.</p><p>When running the driver with the <span class="emphasis"><em>-k</em></span> flag, it will first attempt to
send a <code class="literal">shutdown.return</code> command and if that fails, will fallback to
<code class="literal">shutdown.reboot</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="snmp-subdrivers"></a>5.24. How to make a new subdriver to support another SNMP device</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_overall_concept_3"></a>Overall concept</h4></div></div></div><p>The SNMP protocol allow for a common way to interact with devices over
the network.</p><p>The NUT "snmp-ups" driver is a meta-driver that handles many SNMP devices,
such as UPS and PDU. It consists of a core driver that handles most of the
work of talking to the SNMP agent, and several sub-drivers to handle
specific device manufacturers.  Adding support for a new SNMP device is
easy, because it requires only the creation of a new sub-driver.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_snmp_data_tree"></a>SNMP data Tree</h4></div></div></div><p>From the point of view of writing an SNMP subdriver, an SNMP device
consists of a bunch of variables, called OIDs (for Object IDentifiers).
Some OIDs (such as the current input voltage) are read-only, whereas
others (such as the beeper enabled/disabled/muted status) can be read and
written. OID are grouped together and arranged in a hierarchical tree
shape, similar to directories in a file system.  OID components are
separated by ".", and can be expressed in numeric or textual form.
For example:</p><pre class="literallayout">.iso.org.dod.internet.mgmt.mib-2.system.sysObjectID</pre><p>is equivalent to:</p><pre class="literallayout">.1.3.6.1.2.1.1.2.0</pre><p>Here is an excerpt tree, showing only two OIDs, sysDescr and sysObjectID:</p><pre class="literallayout">.iso
        .org
                .dod
                        .internet
                                .mgmt
                                        .mib-2
                                                .system
                                                        .sysDescr.0 = STRING: Dell UPS Tower 1920W HV
                                                        .sysObjectID.0 = OID: .iso.org.dod.internet.private.enterprises.674.10902.2
                                                        (...)
                                                .upsMIB
                                                        .upsObjects
                                                                .upsIdent
                                                                        .upsIdentModel = STRING: "Dell UPS Tower 1920W HV"
                                                                        (...)
                                .private
                                        .enterprises
                                                .674
                                                        .10902
                                                                .2
                                                                        .100
                                                                                .1.0 = STRING: "Dell UPS Tower 1920W HV"
                                                                                (...)</pre><p>As you can see in the above example, the device name is exposed three times,
through three different MIBs:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Generic MIB-II (RFC 1213):
</p><pre class="literallayout">.iso.org.dod.internet.mgmt.mib-2.system.sysDescr.0 = STRING: Dell UPS Tower 1920W HV
.1.3.6.1.2.1.1.1.0 = STRING: Dell UPS Tower 1920W HV</pre></li><li class="listitem"><p class="simpara">
UPS MIB (RFC 1628):
</p><pre class="literallayout">.iso.org.dod.internet.mgmt.mib-2.upsMIB.upsObjects.upsIdent.upsIdentModel = STRING: "Dell UPS Tower 1920W HV"
.1.3.6.1.2.1.33.1.1.2.0 = STRING: "Dell UPS Tower 1920W HV"</pre></li><li class="listitem"><p class="simpara">
DELL SNMP UPS MIB:
</p><pre class="literallayout">.iso.org.dod.internet.private.enterprises.674.10902.2.100.1.0 = STRING: "Dell UPS Tower 1920W HV"</pre></li></ul></div><p>But only the two last can serve useful data for NUT.</p><p>An highly interesting OID is <span class="strong"><strong>sysObjectID</strong></span>: its value is an OID that refers to
the main MIB of the device. In the above example, the device points us at the
Dell UPS MIB. <span class="strong"><strong>sysObjectID</strong></span>, also called "sysOID" is used by snmp-ups to find
the right mapping structure.</p><p>For more information on SNMP, refer to the
<a class="ulink" href="http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_top">Wikipedia</a>
article, or browse the Internet.</p><p>To be able to convert values, NUT SNMP subdrivers need to provide:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
manufacturer-specific sysOID, to determine which lookup structure applies
to which devices,
</li><li class="listitem">
a mapping of SNMP variables to NUT variables,
</li><li class="listitem">
a mapping of SNMP values to NUT values.
</li></ul></div><p>Moreover, subdrivers might have to provide additional functionality,
such as custom implementations of specific instant commands (load.off,
shutdown.restart), and conversions of manufacturer specific data
formats. At the time of writing this document, snmp-ups doesn’t provide
such mechanisms (only formatting ones), but it is planned in a future release.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_creating_a_subdriver"></a>Creating a subdriver</h4></div></div></div><p>In order to create a subdriver, you will need the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the "MIB definition file. This file has a ".mib" extension, and is
generally available on the accompanying disc, or on the manufacturer
website. It should either be placed in a system directory
(/usr/share/mibs/ or equivalent), or pointed using <span class="strong"><strong>-M</strong></span> option,
</li><li class="listitem">
a network access to the device
</li><li class="listitem">
OR information dumps.
</li></ul></div><p>You can create an initial "stub" subdriver for your device by using the helper
script <span class="strong"><strong>scripts/subdriver/gen-snmp-subdriver.sh</strong></span>. Note that this only creates
a "stub" which MUST be customized to be useful (see CUSTOMIZATION below).</p><p>You have two options to run gen-snmp-subdriver.sh:</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_mode_1_get_snmp_data_from_a_real_agent"></a>mode 1: get SNMP data from a real agent</h5></div></div></div><p>This method requires to have a network access to the device, in order to
automatically retrieve the needed information.</p><p>You have to specify the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>-H</strong></span> host address: is the SNMP host IP address or name
</li><li class="listitem">
<span class="strong"><strong>-c</strong></span> community: is the SNMP v1 community name (default: public)"
</li></ul></div><p>For example:</p><pre class="literallayout">$ gen-snmp-subdriver.sh -H W.X.Y.Z -c foobar -n &lt;MIB name&gt;.mib</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_mode_2_get_data_from_files"></a>mode 2: get data from files</h5></div></div></div><p>This method does not require direct access to the device, at least
not for the one using gen-snmp-subdriver.sh.</p><p>The following SNMP data need to be dumped first:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
sysOID value: for example <span class="emphasis"><em>.1.3.6.1.4.1.705.1</em></span>
</li><li class="listitem"><p class="simpara">
a numeric SNMP walk (OIDs in dotted numeric format) of the tree
pointed by sysOID. For example:
</p><pre class="literallayout">snmpwalk -On -c foobar W.X.Y.Z .1.3.6.1.4.1.705.1 &gt; snmpwalk-On.log</pre></li><li class="listitem"><p class="simpara">
a textual SNMP walk (OIDs in string format) of the tree pointed by
sysOID. For example:
</p><pre class="literallayout">snmpwalk -Os -c foobar W.X.Y.Z .1.3.6.1.4.1.705.1 &gt; snmpwalk-Os.log</pre></li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>If the OID are only partially resolved (i.e, there are still parts
expressed in numeric form), then try using <span class="strong"><strong>-M</strong></span> to point your .mib file.</p></div><p>Then call the script using:</p><pre class="literallayout">$ gen-snmp-subdriver.sh -s &lt;sysOID value&gt; &lt;numeric SNMP walk&gt; &lt;string SNMP walk&gt;</pre><p>For example:</p><pre class="literallayout">$ gen-snmp-subdriver.sh -s .1.3.6.1.4.1.705.1 snmpwalk-On.log snmpwalk-Os.log</pre><p>This script prompts you for a name for the subdriver if you don’t provide it
with <span class="strong"><strong>-n</strong></span>. Use only letters and digits, and use natural capitalization such
as "Camel" (not "camel" or "CAMEL", apart if it natural). The script may
prompt you for additional information.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_integrating_the_subdriver_with_snmp_ups"></a>Integrating the subdriver with snmp-ups</h5></div></div></div><p>Beside of the mandatory customization, there are a few things that you have
to do, as mentioned at the end of the script:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
edit drivers/snmp-ups.h and add #include "&lt;HFILE&gt;.h", where &lt;HFILE&gt; is the
name of the header file, with the <span class="strong"><strong>.h</strong></span> extension,
</li><li class="listitem">
edit drivers/snmp-ups.c and bump DRIVER_VERSION by adding "0.01".
</li><li class="listitem">
also add "&amp;&lt;LDRIVER&gt;" to snmp-ups.c:mib2nut[] list, where &lt;LDRIVER&gt; is the
lower case driver name
</li><li class="listitem">
add "&lt;LDRIVER&gt;-mib.c" to snmp_ups_SOURCES in drivers/Makefile.am
</li><li class="listitem">
add "&lt;LDRIVER&gt;-mib.h" to dist_noinst_HEADERS in drivers/Makefile.am
</li><li class="listitem">
copy "&lt;LDRIVER&gt;-mib.c" and "&lt;LDRIVER&gt;-mib.h" to ../drivers/
</li><li class="listitem"><p class="simpara">
finally call the following, from the top level directory,  to test
compilation:
</p><pre class="literallayout">$ autoreconf &amp;&amp; configure &amp;&amp; make</pre></li></ul></div><p>You can already start experimenting with the new subdriver; but all data
will be prefixed by "unmapped.". You will now have to customize it.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_customization_2"></a>CUSTOMIZATION</h5></div></div></div><p>The initially generated subdriver code is only a stub (mainly a big C
structure to be precise), and will not implement any useful functionality
(in particular, it will be unable to shut down the UPS). In the beginning,
it simply attempts to monitor some UPS variables. To make this driver useful,
you must examine the NUT variables of the form "unmapped.*" in the
hid_info_t data structure (commonly wrapped into <code class="literal">snmp_info_default()</code>
macros for portability), and map them to actual NUT variables and
instant commands. There are currently no step-by-step instructions for
how to do this. Please look at the source files to see how the currently
implemented SNMP subdrivers are written:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
apc-mib.c/h
</li><li class="listitem">
baytech-mib.c/h
</li><li class="listitem">
bestpower-mib.c/h
</li><li class="listitem">
compaq-mib.c/h
</li><li class="listitem">
cyberpower-mib.c/h
</li><li class="listitem">
eaton-*-mib.c/h
</li><li class="listitem">
ietf-mib.c/h
</li><li class="listitem">
mge-mib.c/h
</li><li class="listitem">
netvision-mib.c/h
</li><li class="listitem">
powerware-mib.c/h
</li><li class="listitem">
raritan-pdu-mib.c
</li><li class="listitem">
huawei-mib.c/h
</li></ul></div><p>To help you, above each entry in &lt;LDRIVER&gt;-mib.c, there is a comment that
displays the textual OID name. For example, the following entry:</p><pre class="literallayout">/* upsMIB.upsObjects.upsIdent.upsIdentModel = STRING: "Dell UPS Tower 1920W HV" */
snmp_info_default("ups.model", ST_FLAG_STRING, SU_INFOSIZE,
    ".1.3.6.1.4.1.2254.2.4.1.1.0", NULL, SU_FLAG_OK, NULL),</pre><p>Many times, only the first field will need to be modified, to map to an actual
NUT variable name.</p><p>Check the <a class="link" href="nut-names.html" title="A. NUT command and variable naming scheme">NUT command and variable naming scheme</a> section first
to find a name that matches the OID name (closest fit). If nothing matches,
contact the upsdev list, and we’ll figure it out.</p><p>In the above example, the right NUT variable is obviously "device.model".</p><p>The MIB definition file (.mib) also contains some description of these OIDs,
along with the possible enumerated values.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>To test existing data points (including those not yet translated
to standard NUT mappings conforming to <a class="link" href="nut-names.html" title="A. NUT command and variable naming scheme">NUT command and variable naming scheme</a>), you can use custom drivers built after you
<code class="literal">./configure --with-unmapped-data-points</code>.
Production driver builds must not include any non-standard names.</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="nutdrv_qx-subdrivers"></a>5.25. How to make a new subdriver to support another Q* UPS</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_overall_concept_4"></a>Overall concept</h4></div></div></div><p>The NUT "<span class="strong"><strong>nutdrv_qx</strong></span>" driver is a meta-driver that handles Q* UPS devices.</p><p>It consists of a core driver that handles most of the work of talking to the hardware, and several sub-drivers to handle specific UPS manufacturers.</p><p>Adding support for a new UPS device is easy, because it requires only the creation of a new sub-driver.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Due to historic reasons, there is a bit of a mess with terminology here:
among the set of driver parameters passed on command-line or via <code class="literal">ups.conf</code>,
the <code class="literal">subdriver</code> value is for Serial-over-USB dialect ("usbsubdriver" in code),
and the <code class="literal">protocol</code> value is for Qx dialect (but referred to as "subdriver"
in most of the documentation, and variable names in the code itself)..</p><p>An additional set of source code files named <code class="literal">nutdrv_qx_subdrivername.{c,h}</code>
defines a <code class="literal">subdriver_t</code> entry that is listed as in <code class="literal">subdrivers_list</code> array in
the main <code class="literal">nutdrv_qx.c</code> file.  However, in <code class="literal">ups.conf</code> this entity is referred
to via the communication <code class="literal">protocol</code> keyword, if the end-user wants to pick
one explicitly (bypassing auto-detection).</p><p>The string value of each <code class="literal">protocol</code> setting is derived from the respective
source module’s self-identification, by picking the first space-separated token
(its <code class="literal">NAME</code>, assuming a <code class="literal">NAME VERSION</code> pattern) and making a case-insensitive
comparison.  The self-identification value is maintained as a string macro at
the top of each module’s C source file, and is passed to the main driver code
as part of <code class="literal">subdriver_t</code> structure instance defined in the end of the file.</p><p>Confusingly, there <span class="strong"><strong>is</strong></span> also an optional USB <code class="literal">subdriver</code> setting (available
when the driver is built with USB support), for "Serial-over-USB subdriver
selection", corresponding to entries in the <code class="literal">usbsubdriver</code> array and several
<code class="literal">usbsubdrvname_command()</code> methods defined directly in <code class="literal">nutdrv_qx.c</code>.</p><p>There are also methods called <code class="literal">usbsubdrvname_subdriver()</code> which are called
via <code class="literal">qx_usb_id[]</code> array for USB VendorID/ProductID/iManufacturer/iProduct
based matching, and typically set the <code class="literal">subdriver_command</code> variable to point
to the corresponding <code class="literal">usbsubdrvname_command()</code> method when auto-detection
happens.  Otherwise, this variable is set according to a text name requested
in the <code class="literal">subdriver</code> driver parameter.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_creating_a_subdriver_2"></a>Creating a subdriver</h4></div></div></div><p>In order to develop a new subdriver for a specific UPS you have to know the "idiom" (dialect of the protocol) spoken by that device.</p><p>This kind of devices speaks idioms that can be summed up as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
We send the UPS a query for one or more information
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
If the query is supported by the device, we’ll get a reply that is mostly of a fixed length, therefore, in most cases, each information starts and ends always at the same indexes
</li></ul></div></li><li class="listitem"><p class="simpara">
We send the UPS a command
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
If the command is supported by the device, the UPS will either take action without any reply or reply us with a device-specific answer signaling that the command has been accepted (e.g. <code class="literal">ACK</code>)
</li></ul></div></li><li class="listitem">
If the query/command isn’t supported by the device we’ll get either the query/command echoed back or a device-specific reply signaling that it has been rejected (e.g. <code class="literal">NAK</code>)
</li></ul></div><p>To be supported by this driver the idiom spoken by the UPS must comply to these conditions.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_writing_a_subdriver_2"></a>Writing a subdriver</h4></div></div></div><p>You have to fill the <code class="literal">subdriver_t</code> structure:</p><pre class="screen">typedef struct {
        const char      *name;
        int             (*claim)(void);
        item_t          *qx2nut;
        void            (*initups)(void);
        void            (*initinfo)(void);
        void            (*makevartable)(void);
        const char      *accepted;
        const char      *rejected;
#ifdef TESTING
        testing_t       *testing;
#endif  /* TESTING */
} subdriver_t;</pre><p>Where:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="literal">name</code></strong></span>
</span></dt><dd>
Name of this subdriver: name of the <code class="literal">protocol</code> that will need to be set in the <code class="literal">ups.conf</code> file to use this subdriver plus the internal version of it separated by a space (e.g. "<code class="literal">Megatec 0.01</code>").
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">claim</code></strong></span>
</span></dt><dd>
This function allows the subdriver to "claim" a device: return <code class="literal">1</code> if the device is supported by this subdriver, else <code class="literal">0</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">qx2nut</code></strong></span>
</span></dt><dd>
Main table of vars and instcmds: an array of <code class="literal">item_t</code> mapping a UPS idiom to NUT.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">initups</code></strong></span> (optional)
</span></dt><dd>
Subdriver-specific <code class="literal">upsdrv_initups</code>.
This function will be called at the end of nutdrv_qx’s own <code class="literal">upsdrv_initups</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">initinfo</code></strong></span> (optional)
</span></dt><dd>
Subdriver-specific <code class="literal">upsdrv_initinfo</code>.
This function will be called at the end of nutdrv_qx’s own <code class="literal">upsdrv_initinfo</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">makevartable</code></strong></span> (optional)
</span></dt><dd>
Function to add subdriver-specific <code class="literal">ups.conf</code> vars and flags.
Make sure not to collide with other subdrivers' vars and flags.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">accepted</code></strong></span> (optional)
</span></dt><dd>
String to match if the driver is expecting a reply from the UPS on instcmd/setvar in case of success.
This comparison is done after the answer we got back from the UPS has been processed to get the value we are searching, so you don’t have to include the trailing carriage return (<code class="literal">\r</code>) and you can decide at which index of the answer the value should start or end setting the appropriate <code class="literal">from</code> and <code class="literal">to</code> in the <code class="literal">item_t</code> (see <a class="link" href="new-drivers.html#_mapping_an_idiom_to_nut" title="Mapping an idiom to NUT">Mapping an idiom to NUT</a>).
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">rejected</code></strong></span> (optional)
</span></dt><dd>
String to match if the driver is expecting a reply from the UPS in case of error.
Note that this comparison is done on the answer we got back from the UPS before it has been processed, so include also the trailing carriage return (<code class="literal">\r</code>) and whatever character is expected.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">testing</code></strong></span>
</span></dt><dd><p class="simpara">
Testing table (an array of <code class="literal">testing_t</code>) that will hold the commands and the replies used for testing the subdriver.
</p><p class="simpara"><code class="literal">testing_t</code>:</p><pre class="screen">typedef struct {
        const char      *cmd;
        const char      answer[SMALLBUF];
        const int       answer_len;
} testing_t;</pre><p class="simpara">Where:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="literal">cmd</code></strong></span>
</span></dt><dd>
Command to match.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">answer</code></strong></span>
</span></dt><dd><p class="simpara">
Answer for that command.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>If <code class="literal">answer</code> contains inner <code class="literal">\0</code>s, in order to preserve them, <code class="literal">answer_len</code> as well as an <code class="literal">item_t</code>'s <code class="literal">preprocess_answer()</code> function must be set.</p></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">answer_len</code></strong></span>
</span></dt><dd><p class="simpara">
Answer length:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
if set to <code class="literal">-1</code> → auto calculate answer length (treat <code class="literal">answer</code> as a null-terminated string),
</li><li class="listitem">
otherwise → use the provided length (if reasonable) and preserve inner <code class="literal">\0</code>s (treat <code class="literal">answer</code> as a sequence of bytes till the <code class="literal">item_t</code>'s <code class="literal">preprocess_answer()</code> function gets called).
</li></ul></div></dd></dl></div><p class="simpara">For more information, see <a class="link" href="new-drivers.html#_mapping_an_idiom_to_nut" title="Mapping an idiom to NUT">Mapping an idiom to NUT</a>.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_mapping_an_idiom_to_nut"></a>Mapping an idiom to NUT</h4></div></div></div><p>If you understand the idiom spoken by your device, you can easily map it to NUT variables and instant commands, filling <code class="literal">qx2nut</code> with an array of <code class="literal">item_t</code> data structure:</p><pre class="screen">typedef struct item_t {
        const char      *info_type;
        const int       info_flags;
        info_rw_t       *info_rw;
        const char      *command;
        char            answer[SMALLBUF];
        const int       answer_len;
        const char      leading;
        char            value[SMALLBUF];
        const int       from;
        const int       to;
        const char      *dfl;
        unsigned long   qxflags;
        int             (*preprocess_command)(struct item_t *item, char *command, const size_t commandlen);
        int             (*preprocess_answer)(struct item_t *item, const int len);
        int             (*preprocess)(struct item_t *item, char *value, const size_t valuelen);
} item_t;</pre><p>Where:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="literal">info_type</code></strong></span>
</span></dt><dd>
NUT variable name, otherwise, if <code class="literal">QX_FLAG_NONUT</code> is set, name to print to logs and if both <code class="literal">QX_FLAG_NONUT</code> and <code class="literal">QX_FLAG_SETVAR</code> are set, name of the var to retrieve from <code class="literal">ups.conf</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">info_flags</code></strong></span>
</span></dt><dd>
NUT flags (<code class="literal">ST_FLAG_*</code> values to set in <code class="literal">dstate_addinfo</code>).
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">info_rw</code></strong></span>
</span></dt><dd><p class="simpara">An array of <code class="literal">info_rw_t</code> to handle r/w variables:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If <code class="literal">ST_FLAG_STRING</code> is set in <code class="literal">info_flags</code> it’ll be used to set the length of the string (in <code class="literal">dstate_setaux</code>)
</li><li class="listitem">
If <code class="literal">QX_FLAG_ENUM</code> is set in <code class="literal">qxflags</code> it’ll be used to set enumerated values (in <code class="literal">dstate_addenum</code>)
</li><li class="listitem">
If <code class="literal">QX_FLAG_RANGE</code> is set in <code class="literal">qxflags</code> it’ll be used to set range boundaries (in <code class="literal">dstate_addrange</code>)
</li></ul></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>If <code class="literal">QX_FLAG_SETVAR</code> is set the value given by the user will be checked against these infos.</p></div><p class="simpara"><code class="literal">info_rw_t</code>:</p><pre class="screen">typedef struct {
        char    value[SMALLBUF];
        int     (*preprocess)(char *value, const size_t len);
} info_rw_t;</pre><p class="simpara">Where:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="literal">value</code></strong></span>
</span></dt><dd>
Value for enum/range, or length for <code class="literal">ST_FLAG_STRING</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">preprocess(value, len)</code></strong></span>
</span></dt><dd><p class="simpara">
Optional function to preprocess range/enum <code class="literal">value</code>.
</p><p class="simpara">This function will be given <code class="literal">value</code> and its <code class="literal">size_t</code> and must return either <code class="literal">0</code> if <code class="literal">value</code> is supported or <code class="literal">-1</code> if not supported.</p></dd></dl></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">command</code></strong></span>
</span></dt><dd>
Command sent to the UPS to get answer, or to execute an instant command, or to set a variable.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">answer</code></strong></span>
</span></dt><dd><p class="simpara">
Answer from the UPS, filled at runtime.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>If you expect a non-valid C string (e.g.: inner <code class="literal">\0</code>s) or need to perform actions before the answer is used (and treated as a null-terminated string), you should set a <code class="literal">preprocess_answer()</code> function.</p></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">answer_len</code></strong></span>
</span></dt><dd>
Expected minimum length of the answer.
Set it to <code class="literal">0</code> if there’s no minimum length to look after.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">leading</code></strong></span>
</span></dt><dd>
Expected leading character of the answer (optional), e.g. <code class="literal">#</code>, <code class="literal">(</code> …
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">value</code></strong></span>
</span></dt><dd>
Value from the answer, filled at runtime (i.e. <code class="literal">answer</code> in the interval [<code class="literal">from</code> to <code class="literal">to</code>]).
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">from</code></strong></span>
</span></dt><dd>
Position of the starting character of the info we’re after in the answer.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">to</code></strong></span>
</span></dt><dd>
Position of the ending character of the info we’re after in the answer: use <code class="literal">0</code> if all the remaining of the line is needed.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">dfl</code></strong></span>
</span></dt><dd><p class="simpara">
printf format to store value from the UPS in NUT variables.
Set it either to <code class="literal">%s</code> for strings or to a floating point specifier (e.g. <code class="literal">%.1f</code>) for numbers.
</p><p class="simpara">Otherwise:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
If <code class="literal">QX_FLAG_ABSENT</code> → default value
</li><li class="listitem">
If <code class="literal">QX_FLAG_CMD</code> → default command value
</li></ul></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">qxflags</code></strong></span>
</span></dt><dd><p class="simpara">
Driver’s own flags.
</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><tbody><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_STATIC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Retrieve this variable only once.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_SEMI_STATIC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Retrieve this info smartly, i.e. only when a command/setvar is executed and we expect that data could have been changed.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_ABSENT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data is absent in the device, use default value.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_QUICK_POLL</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Mandatory vars.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_CMD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Instant command.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_SETVAR</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The var is settable and the actual item stores info on how to set it.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_TRIM</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>This var’s value need to be trimmed of leading/trailing spaces/hashes.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_ENUM</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Enum values exist.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_RANGE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Ranges for this var are available.</p></td></tr><tr><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">QX_FLAG_NONUT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>This var doesn’t have a corresponding var in NUT.</p></td></tr><tr><td style="" align="left" valign="top"><p><code class="literal">QX_FLAG_SKIP</code></p></td><td style="" align="left" valign="top"><p>Skip this var: this item won’t be processed.</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The driver will run a so-called <code class="literal">QX_WALKMODE_INIT</code> in <code class="literal">initinfo</code> walking through all the items in <code class="literal">qx2nut</code>, adding instant commands and the like.
From then on it’ll run a so-called <code class="literal">QX_WALKMODE_QUICK_UPDATE</code> just to see if the UPS is still there and then it’ll do a so-called <code class="literal">QX_WALKMODE_FULL_UPDATE</code> to update all the vars.</p><p>If there’s a problem with a var in <code class="literal">QX_WALKMODE_INIT</code>, the driver will automagically set <code class="literal">QX_FLAG_SKIP</code> on it and then it’ll skip that item in <code class="literal">QX_WALKMODE_QUICK_UPDATE</code>/<code class="literal">QX_WALKMODE_FULL_UPDATE</code>, provided that the item has not the flag <code class="literal">QX_FLAG_QUICK_POLL</code> set, in that case the driver will set <code class="literal">datastale</code>.</p></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">preprocess_command(item, command, commandlen)</code></strong></span>
</span></dt><dd>
Last chance to preprocess the command to be sent to the UPS (e.g. to add CRC, …).
This function is given the currently processed item (<code class="literal">item</code>), the command to be sent to the UPS (<code class="literal">command</code>) and its size_t (<code class="literal">commandlen</code>).
Return <code class="literal">-1</code> in case of errors, else <code class="literal">0</code>.
<code class="literal">command</code> must be filled with the actual command to be sent to the UPS.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">preprocess_answer(item, len)</code></strong></span>
</span></dt><dd>
Function to preprocess the answer we got from the UPS before we do anything else (e.g. for CRC, decoding, …).
This function is given the currently processed item (<code class="literal">item</code>) with the answer we got from the UPS unmolested and already stored in <code class="literal">item</code>'s <code class="literal">answer</code> and the length of that answer (<code class="literal">len</code>).
Return <code class="literal">-1</code> in case of errors, else the length of the newly allocated <code class="literal">item</code>'s <code class="literal">answer</code> (from now on, treated as a null-terminated string).
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">preprocess(item, value, valuelen)</code></strong></span>
</span></dt><dd><p class="simpara">
Function to preprocess the data from/to the UPS: you are given the currently processed item (<code class="literal">item</code>), a char array (<code class="literal">value</code>) and its <code class="literal">size_t</code> (<code class="literal">valuelen</code>).
Return <code class="literal">-1</code> in case of errors, else <code class="literal">0</code>.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
If <code class="literal">QX_FLAG_SETVAR</code>/<code class="literal">QX_FLAG_CMD</code> is set then the item is processed before the command is sent to the UPS so that you can fill it with the value provided by the user.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>In this case <code class="literal">value</code> must be filled with the command to be sent to the UPS.</p></div></li><li class="listitem"><p class="simpara">
Otherwise the function will be used to process the value we got from the answer of the UPS before it’ll get stored in a NUT variable.
</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>In this case <code class="literal">value</code> must be filled with the processed value already compliant to NUT standards.</p></div></li></ul></div></dd></dl></div><div class="important" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Important</h3><p>You must provide an <code class="literal">item_t</code> with <code class="literal">QX_FLAG_SETVAR</code> and its boundaries set for both <code class="literal">ups.delay.start</code> and <code class="literal">ups.delay.shutdown</code> to map the driver variables <code class="literal">ondelay</code> and <code class="literal">offdelay</code>, as they will be used in the shutdown sequence.</p></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>In order to keep the data flow at minimum you should keep together the items in <code class="literal">qx2nut</code> that need data from the same query (i.e. <code class="literal">command</code>): doing so the driver will send the query only once and then every <code class="literal">item_t</code> processed after the one that got the answer, provided that it’s filled with the same <code class="literal">command</code> and that the answer wasn’t <code class="literal">NULL</code>, will get that <code class="literal">answer</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_examples"></a>Examples</h4></div></div></div><p>The following examples are from the <code class="literal">voltronic</code> subdriver.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_simple_vars"></a>Simple vars</h5></div></div></div><p>We know that when the UPS is queried for status with <code class="literal">QGS\r</code>, it replies with something like <code class="literal">(234.9 50.0 229.8 50.0 000.0 000 369.1 ---.- 026.5 ---.- 018.8 100000000001\r</code> and we want to access the output voltage (the third token, in this case <code class="literal">229.8</code>).</p><pre class="screen">&gt; [QGS\r]
&lt; [(234.9 50.0 229.8 50.0 000.0 000 369.1 ---.- 026.5 ---.- 018.8 100000000001\r]
   0123456789012345678901234567890123456789012345678901234567890123456789012345
   0         1         2         3         4         5         6         7</pre><p>Here’s the <code class="literal">item_t</code>:</p><pre class="screen">{ "output.voltage", 0, NULL, "QGS\r", "", 76, '(', "", 12, 16, "%.1f", 0, NULL, NULL, NULL },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">output.voltage</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QGS\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">76</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">12</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">16</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">%.1f</code>
</p>
<p>We are expecting a number, so at first the core driver will check if it’s made up entirely of digits/points/spaces, then it’ll convert it into a double.
Because of that we need to provide a floating point specifier.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_mandatory_vars"></a>Mandatory vars</h5></div></div></div><p>Also from <code class="literal">QGS\r</code>, we want to process the 9th status bit <code class="literal">10000000</code><span class="strong"><strong><code class="literal">0</code></strong></span><code class="literal">001</code> that tells us whether the UPS is shutting down or not.</p><pre class="screen">&gt; [QGS\r]
&lt; [(234.9 50.0 229.8 50.0 000.0 000 369.1 ---.- 026.5 ---.- 018.8 100000000001\r]
   0123456789012345678901234567890123456789012345678901234567890123456789012345
   0         1         2         3         4         5         6         7</pre><p>Here’s the <code class="literal">item_t</code>:</p><pre class="screen">{ "ups.status", 0, NULL, "QGS\r", "", 76, '(', "", 71, 71, "%s", QX_FLAG_QUICK_POLL, NULL, NULL, voltronic_status },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">ups.status</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QGS\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">76</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">71</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">71</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">%s</code>
</p>
<p>Since a <code class="literal">preprocess</code> function is defined for this item, this could have been <code class="literal">NULL</code>, however, if we want — like here — we can use it in our <code class="literal">preprocess</code> function.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_QUICK_POLL</code> → this item will be polled every time the driver will check for updates.
Since this item is mandatory to run the driver, if a problem arises in <code class="literal">QX_WALKMODE_INIT</code> the driver won’t skip it and it will set <code class="literal">datastale</code>.
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_status</code>
</p>
<p>This function will be called <span class="strong"><strong>after</strong></span> the <code class="literal">command</code> has been sent to the UPS and we got back the <code class="literal">answer</code> and stored the <code class="literal">value</code> in order to process it to NUT standards: in this case we will convert the binary <code class="literal">value</code> to a NUT status.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_settable_vars"></a>Settable vars</h5></div></div></div><p>So your UPS reports its battery type when queried for <code class="literal">QBT\r</code>; we are expecting an answer like <code class="literal">(01\r</code> and we know that the values can be mapped as follows: <code class="literal">00</code> → "Li", <code class="literal">01</code> → "Flooded" and <code class="literal">02</code> → "AGM".</p><pre class="screen">&gt; [QBT\r]
&lt; [(01\r]       &lt;- 00="Li", 01="Flooded" or 02="AGM"
   0123
   0</pre><p>Here’s the <code class="literal">item_t</code>:</p><pre class="screen">{ "battery.type", ST_FLAG_RW, voltronic_e_batt_type, "QBT\r", "", 4, '(', "", 1, 2, "%s",
  QX_FLAG_SEMI_STATIC | QX_FLAG_ENUM, NULL, NULL, voltronic_p31b },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">battery.type</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">ST_FLAG_RW</code> → this is a r/w var
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_e_batt_type</code>
</p>
<p>The values stored here will be added to the NUT variable, setting its boundaries: in this case <code class="literal">Li</code>, <code class="literal">Flooded</code> and <code class="literal">AGM</code> will be added as enumerated values.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QBT\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">4</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">1</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">2</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">%s</code>
</p>
<p>Since a <code class="literal">preprocess</code> function is defined for this item, this could have been <code class="literal">NULL</code>, however, if we want — like here — we can use it in our <code class="literal">preprocess</code> function.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_SEMI_STATIC</code> → this item changes — and will therefore be updated — only when we send a command/setvar to the UPS
</p>
<p><code class="literal">QX_FLAG_ENUM</code> → this r/w variable is of the enumerated type and the enumerated values are listed in the <code class="literal">info_rw</code> structure (i.e. <code class="literal">voltronic_e_batt_type</code>)</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_p31b</code>
</p>
<p>This function will be called <span class="strong"><strong>after</strong></span> the <code class="literal">command</code> has been sent to the UPS and we got back the <code class="literal">answer</code> and stored the <code class="literal">value</code> in order to process it to NUT standards: in this case we will check if the value is in the range and then publish the human readable form of it (i.e. <code class="literal">Li</code>, <code class="literal">Flooded</code> or <code class="literal">AGM</code>).</p>
</td></tr></tbody></table></div><p>We also know that we can change battery type with the <code class="literal">PBTnn\r</code> command; we are expecting either <code class="literal">(ACK\r</code> if the command succeeded or <code class="literal">(NAK\r</code> if the command is rejected.</p><pre class="screen">&gt; [PBTnn\r]             nn = 00/01/02
&lt; [(ACK\r]
   01234
   0</pre><p>Here’s the <code class="literal">item_t</code>:</p><pre class="screen">{ "battery.type", 0, voltronic_e_batt_type, "PBT%02.0f\r", "", 5, '(', "", 1, 4, NULL,
  QX_FLAG_SETVAR | QX_FLAG_ENUM, NULL, NULL, voltronic_p31b_set },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">battery.type</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_e_batt_type</code>
</p>
<p>The value provided by the user will be automagically checked by the core nutdrv_qx driver against the enumerated values already set by the non setvar item (i.e. <code class="literal">Li</code>, <code class="literal">Flooded</code> or <code class="literal">AGM</code>), so this could have been <code class="literal">NULL</code>, however if we want — like here — we can use it in our <code class="literal">preprocess</code> function.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">PBT%02.0f\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">5</code> ← either <code class="literal">(NAK\r</code> or <code class="literal">(ACK\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">1</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">3</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_SETVAR</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_SETVAR</code> → this item is used to set the variable <code class="literal">info_type</code> (i.e. <code class="literal">battery.type</code>)
</p>
<p><code class="literal">QX_FLAG_ENUM</code> → this r/w variable is of the enumerated type and the enumerated values are listed in the <code class="literal">info_rw</code> structure (i.e. <code class="literal">voltronic_e_batt_type</code>)</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_p31b_set</code>
</p>
<p>This function will be called <span class="strong"><strong>before</strong></span> the <code class="literal">command</code> is sent to the UPS so that we can fill <code class="literal">command</code> with the value provided by the user: in this case the function will simply translate the human readable form of battery type (i.e. <code class="literal">Li</code>, <code class="literal">Flooded</code> or <code class="literal">AGM</code>) to the UPS compliant type (i.e. <code class="literal">00</code>, <code class="literal">01</code> and <code class="literal">02</code>) and then fill <code class="literal">value</code> (the second argument passed to the <code class="literal">preprocess</code> function).</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_instant_commands_3"></a>Instant commands</h5></div></div></div><p>We know that we have to send to the UPS <code class="literal">Tnn\r</code> or <code class="literal">T.n\r</code> in order to start a battery test lasting <code class="literal">nn</code> minutes or <code class="literal">.n</code> minutes: we are expecting either <code class="literal">(ACK\r</code> on success or <code class="literal">(NAK\r</code> if the command is rejected.</p><pre class="screen">&gt; [Tnn\r]
&lt; [(ACK\r]
   01234
   0</pre><p>Here’s the <code class="literal">item_t</code>:</p><pre class="screen">{ "test.battery.start", 0, NULL, "T%s\r", "", 5, '(', "", 1, 4, NULL, QX_FLAG_CMD, NULL, NULL, voltronic_process_command },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">test.battery.start</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">T%s\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">5</code> ← either <code class="literal">(NAK\r</code> or <code class="literal">(ACK\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">1</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">3</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_CMD</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_CMD</code> → this item is an instant command that will be fired when <code class="literal">info_type</code> (i.e. <code class="literal">test.battery.start</code>) is called
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_process_command</code>
</p>
<p>This function will be called <span class="strong"><strong>before</strong></span> the <code class="literal">command</code> is sent to the UPS so that we can fill <code class="literal">command</code> with the value provided by the user: in this case the function will check if the value is in the accepted range and then fill <code class="literal">value</code> (the second argument passed to the <code class="literal">preprocess</code> function) with <code class="literal">command</code> and the given value.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_information_absent_in_the_device"></a>Information absent in the device</h5></div></div></div><p>In order to set the server-side var <code class="literal">ups.delay.start</code>, that will be then used by the driver, we have to provide the following <code class="literal">item_t</code>:</p><pre class="screen">{ "ups.delay.start", ST_FLAG_RW, voltronic_r_ondelay, NULL, "", 0, 0, "", 0, 0, "180",
  QX_FLAG_ABSENT | QX_FLAG_SETVAR | QX_FLAG_RANGE, NULL, NULL, voltronic_process_setvar },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">ups.delay.start</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">ST_FLAG_RW</code> → this is a r/w var
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_r_ondelay</code>
</p>
<p>The values stored here will be added to the NUT variable, setting its boundaries: in this case <code class="literal">0</code> and <code class="literal">599940</code> will be set as the minimum and maximum value of the variable’s range.
Those values will then be used by the driver to check the user provided value.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_ABSENT</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">180</code> ← the default value that will be set for this variable
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_ABSENT</code> → this item isn’t available in the device
</p>
<p><code class="literal">QX_FLAG_SETVAR</code> → this item is used to set the variable <code class="literal">info_type</code> (i.e. <code class="literal">ups.delay.start</code>)</p>
<p><code class="literal">QX_FLAG_RANGE</code> → this r/w variable has a settable range and its boundaries are listed in the <code class="literal">info_rw</code> structure (i.e. <code class="literal">voltronic_r_ondelay</code>)</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_process_setvar</code>
</p>
<p>This function will be called, in setvar, before the driver stores the value in the NUT var: here it’s used to truncate the user-provided value to the nearest settable interval.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_information_not_yet_available_in_nut"></a>Information not yet available in NUT</h5></div></div></div><p>If your UPS reports some data items that are not yet available as NUT variables and you need to process them, you can add them in <code class="literal">item_t</code> data structure adding the <code class="literal">QX_FLAG_NONUT</code> flag to its <code class="literal">qxflags</code>: the info will then be printed to the logs.</p><p>So we know that the UPS reports actual input/output phase angles when queried for <code class="literal">QPD\r</code>:</p><pre class="screen">&gt; [QPD\r]
&lt; [(000 120\r]  &lt;- Input Phase Angle -- Output Phase Angle
   012345678
   0</pre><p>Here’s the <code class="literal">item_t</code> for input phase angle:</p><pre class="screen">{ "input_phase_angle", 0, NULL, "QPD\r", "", 9, '(', "", 1, 3, "%03.0f",
  QX_FLAG_STATIC | QX_FLAG_NONUT, NULL, NULL, voltronic_phase },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">input_phase_angle</code>
</p>
<p>This information will be used to print the value we got back from the UPS in the logs.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QPD\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">9</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">1</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">3</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">%03.0f</code>
</p>
<p>If there’s no <code class="literal">preprocess</code> function, the format is used to print the value to the logs.
Here instead it’s used by the <code class="literal">preprocess</code> function.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_STATIC</code> → this item doesn’t change
</p>
<p><code class="literal">QX_FLAG_NONUT</code> → this item doesn’t have yet a NUT variable</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_phase</code>
</p>
<p>This function will be called <span class="strong"><strong>after</strong></span> the <code class="literal">command</code> has been sent to the UPS so that we can parse the value we got back and check it.</p>
</td></tr></tbody></table></div><p>Here’s the <code class="literal">item_t</code> for output phase angle:</p><pre class="screen">{ "output_phase_angle", ST_FLAG_RW, voltronic_e_phase, "QPD\r", "", 9, '(', "", 5, 7, "%03.0f",
  QX_FLAG_SEMI_STATIC | QX_FLAG_ENUM | QX_FLAG_NONUT, NULL, NULL, voltronic_phase },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">output_phase_angle</code>
</p>
<p>This information will be used to print the value we got back from the UPS in the logs.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">ST_FLAG_RW</code>
</p>
<p>This could also be <code class="literal">0</code> (it’s not really used by the driver), but it’s set to <code class="literal">ST_FLAG_RW</code> for cohesion with other rw vars — also, if ever a NUT variable would become available for this item, it’ll be easier to change this item and its <code class="literal">QX_FLAG_SETVAR</code> counterpart to use it.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_e_phase</code>
</p>
<p>Enumerated list of available value (here: <code class="literal">000</code>, <code class="literal">120</code>, <code class="literal">240</code> and <code class="literal">360</code>).
Since <code class="literal">QX_FLAG_NONUT</code> is set the driver will print those values to the logs, plus you could use it in the <code class="literal">preprocess</code> function to check the value we got back from the UPS (as done here).</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QPD\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">9</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code> 
</p>
</td><td style="" valign="top">
<p>
<code class="literal">5</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">7</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">%03.0f</code>
</p>
<p>If there’s no <code class="literal">preprocess</code> function, the format is used to print the value to the logs.
Here instead it’s used by the <code class="literal">preprocess</code> function.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_SEMI_STATIC</code> → this item changes — and will therefore be updated — only when we send a command/setvar to the UPS
</p>
<p><code class="literal">QX_FLAG_ENUM</code> → this r/w variable is of the enumerated type and the enumerated values are listed in the <code class="literal">info_rw</code> structure (i.e. <code class="literal">voltronic_e_phase</code>).</p>
<p><code class="literal">QX_FLAG_NONUT</code> → this item doesn’t have yet a NUT variable</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_phase</code>
</p>
<p>This function will be called <span class="strong"><strong>after</strong></span> the <code class="literal">command</code> has been sent to the UPS so that we can parse the value we got back and check it.
Here it’s used also to store a var that will then be used to check the value in setvar’s preprocess function.</p>
</td></tr></tbody></table></div><p>If you need also to change some values in the UPS you can add a <code class="literal">ups.conf</code> var/flag in the subdriver’s own <code class="literal">makevartable</code> and then process it adding to its <code class="literal">qxflags</code> both <code class="literal">QX_FLAG_NONUT</code> and <code class="literal">QX_FLAG_SETVAR</code>: this item will be processed only once in <code class="literal">QX_WALKMODE_INIT</code>.</p><p>The driver will check if the var/flag is defined in <code class="literal">ups.conf</code>: if so, it’ll then call <code class="literal">setvar</code> passing to this item the defined value, if any, and then it’ll print the results in the logs.</p><p>We know we can set output phase angle sending <code class="literal">PPDnnn\r</code> to the UPS:</p><pre class="screen">&gt; [PPDn\r]              n = (000, 120, 180 or 240)
&lt; [(ACK\r]
   01234
   0</pre><p>Here’s the <code class="literal">item_t</code></p><pre class="screen">{ "output_phase_angle", 0, voltronic_e_phase, "PPD%03.0f\r", "", 5, '(', "", 1, 4, NULL,
  QX_FLAG_SETVAR | QX_FLAG_ENUM | QX_FLAG_NONUT, NULL, NULL, voltronic_phase_set },</pre><div class="horizontal"><table class="horizontal" cellpadding="4px" style="border: none;"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td style="" valign="top">
<p>
<code class="literal">info_type</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">output_phase_angle</code>
</p>
<p>This information will be used to print the value we got back from the UPS in the logs and to retrieve the user-provided value in <code class="literal">ups.conf</code>.
So, name it after the variable you created to use in <code class="literal">ups.conf</code> in the subdriver’s own <code class="literal">makevartable</code>.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_flags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">info_rw</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_e_phase</code>
</p>
<p>Enumerated list of available values (here: <code class="literal">000</code>, <code class="literal">120</code>, <code class="literal">240</code> and <code class="literal">360</code>).
The value provided by the user will be automagically checked by the core nutdrv_qx driver against the enumerated values stored here.</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">PPD%03.0f\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">answer_len</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">5</code> ← either <code class="literal">(NAK\r</code> or <code class="literal">(ACK\r</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">leading</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">(</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">value</code>
</p>
</td><td style="" valign="top">
<p>
Filled at runtime
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">from</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">1</code> → the index at which the info (i.e. <code class="literal">value</code>) starts
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">to</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">3</code> → the index at which the info (i.e. <code class="literal">value</code>) ends
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">dfl</code>
</p>
</td><td style="" valign="top">
<p>
Not used for <code class="literal">QX_FLAG_SETVAR</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">qxflags</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">QX_FLAG_SETVAR</code> → this item is used to set the variable <code class="literal">info_type</code> (i.e. <code class="literal">output_phase_angle</code>)
</p>
<p><code class="literal">QX_FLAG_ENUM</code> → this r/w variable is of the enumerated type and the enumerated values are listed in the <code class="literal">info_rw</code> structure (i.e. <code class="literal">voltronic_e_phase</code>).</p>
<p><code class="literal">QX_FLAG_NONUT</code> → this item doesn’t have yet a NUT variable</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_command</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess_answer</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">NULL</code>
</p>
</td></tr><tr><td style="" valign="top">
<p>
<code class="literal">preprocess</code>
</p>
</td><td style="" valign="top">
<p>
<code class="literal">voltronic_phase_set</code>
</p>
<p>This function will be called <span class="strong"><strong>before</strong></span> the <code class="literal">command</code> is sent to the UPS so that we can check user-provided value and fill <code class="literal">command</code> with it and then fill <code class="literal">value</code> (the second argument passed to the <code class="literal">preprocess</code> function).</p>
</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_support_functions"></a>Support functions</h4></div></div></div><p>You are already given the following functions:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="literal">int   instcmd(const char *cmdname, const char *extradata)</code></strong></span>
</span></dt><dd><p class="simpara">
Execute an instant command. In detail:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
look up the given <code class="literal">cmdname</code> in the qx2nut data structure (if not found, try to fallback to commonly known commands);
</li><li class="listitem">
if <code class="literal">cmdname</code> is found, call its preprocess function, passing to it <code class="literal">extradata</code>, if any, otherwise its <code class="literal">dfl</code> value, if any;
</li><li class="listitem">
send the command to the device and check the reply.
</li></ul></div><p class="simpara">Return <code class="literal">STAT_INSTCMD_INVALID</code> if the command is invalid, <code class="literal">STAT_INSTCMD_FAILED</code> if it failed, <code class="literal">STAT_INSTCMD_HANDLED</code> on success.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">int   setvar(const char *varname, const char *val)</code></strong></span>
</span></dt><dd>
Set r/w variable to a value after it has been checked against its <code class="literal">info_rw</code> structure.
Return <code class="literal">STAT_SET_HANDLED</code> on success, otherwise <code class="literal">STAT_SET_UNKNOWN</code>.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">item_t        *find_nut_info(const char *varname, const unsigned long flag, const unsigned long noflag)</code></strong></span>
</span></dt><dd><p class="simpara">
Find an item of <code class="literal">item_t</code> type in <code class="literal">qx2nut</code> data structure by its <code class="literal">info_type</code>, optionally filtered by its <code class="literal">qxflags</code>, and return it if found, otherwise return <code class="literal">NULL</code>.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">flag</code>: flags that have to be set in the item, i.e. if one of the flags is absent in the item it won’t be returned.
</li><li class="listitem">
<code class="literal">noflag</code>: flags that have to be absent in the item, i.e. if at least one of the flags is set in the item it won’t be returned.
</li></ul></div></dd><dt><span class="term">
<span class="strong"><strong><code class="literal">int   qx_process(item_t *item, const char *command)</code></strong></span>
</span></dt><dd>
Send <code class="literal">command</code> (a null-terminated byte string) or, if it is <code class="literal">NULL</code>, send the command stored in the <code class="literal">item</code> to the UPS and process the reply, saving it in <code class="literal">item</code>'s <code class="literal">answer</code>.
Return <code class="literal">-1</code> on errors, <code class="literal">0</code> on success.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">int   ups_infoval_set(item_t *item)</code></strong></span>
</span></dt><dd>
Process the value we got back from the UPS (set status bits and set the value of other parameters), calling the <code class="literal">item</code>-specific <code class="literal">preprocess</code> function, if any, otherwise executing the standard preprocessing (including trimming if <code class="literal">QX_FLAG_TRIM</code> is set).
Return <code class="literal">-1</code> on failure, <code class="literal">0</code> for a status update and <code class="literal">1</code> in all other cases.
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">int   qx_status(void)</code></strong></span>
</span></dt><dd>
Return the currently processed status so that it can be checked with one of the <code class="literal">status_bit_t</code> passed to the <code class="literal">STATUS()</code> macro (see <code class="literal">nutdrv_qx.h</code>).
</dd><dt><span class="term">
<span class="strong"><strong><code class="literal">void  update_status(const char *nutvalue)</code></strong></span>
</span></dt><dd>
If you need to edit the current status call this function with one of the NUT status (all but <code class="literal">OB</code> are supported, simply set it as not <code class="literal">OL</code>); prefix them with an exclamation mark if you want to clear them from the status (e.g. <code class="literal">!OL</code>).
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_armac_subdriver"></a>Armac Subdriver</h4></div></div></div><p>Armac subdriver is based on reverse engineering of Power Manager II software by
Richcomm Technologies written in 2005 that is still (as of 2023) being
distributed as a valid software for freshly sold UPS of various manufacturers.
It uses commands as defined for Megatec protocol - but has a different
communication mechanism.</p><p>It uses two types of USB interrupt transfers:
- 4 bytes to send a command (usually single transfer).
- 6 byte chunk to read a reply (multiple transfers).</p><p>Transfers are similar to those of the richcomm nut driver, but the transferred
data is not short binary commands. Instead, serial text data is overlaid in
these transfers in a way that creates a badly made USB serial interface.  UPS
reply looks similar to this:</p><pre class="literallayout"> 0  1  2  3  4  5
HL 00 00 00 00 00</pre><p>HL is a control byte. Its high nibble meaning is unknown. It changes between
two possible values during transmission. Low nibble encodes number of bytes
that have a meaning in the transaction. For example there are 5 bytes that
might contain ASCII serial data, but only some might be valid, and other might
be random, stale buffer data, etc.</p><p>What follows is set of observed transmissions by various UPSes gathered from
Github issues.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="_transfer_dumps"></a>Transfer dumps</h5></div></div></div><p>## Vultech V2000</p><pre class="screen">419.987514     [D4] armac command Q1
419.988307     [D4] armac cleanup ret i=0 ret=6 ctrl=c0
420.119402     [D4] read: ret 6 buf 81: 28 30 31 30 30  &gt;(0100&lt;
420.130383     [D4] read: ret 6 buf c1: 32 30 31 30 30  &gt;20100&lt;
420.141408     [D4] read: ret 6 buf 82: 33 33 31 30 30  &gt;33100&lt;
420.152201     [D4] read: ret 6 buf c3: 2e 30 20 30 30  &gt;.0 00&lt;
420.153237     [D4] read: ret 6 buf 82: 30 30 20 30 30  &gt;00 00&lt;
420.164299     [D4] read: ret 6 buf c1: 30 30 20 30 30  &gt;00 00&lt;
420.175293     [D4] read: ret 6 buf 82: 2e 30 20 30 30  &gt;.0 00&lt;
420.186358     [D4] read: ret 6 buf c3: 20 32 33 30 30  &gt; 2300&lt;
420.190322     [D4] read: ret 6 buf 83: 33 2e 30 30 30  &gt;3.000&lt;
420.194323     [D4] read: ret 6 buf c1: 20 2e 30 30 30  &gt; .000&lt;
420.205358     [D4] read: ret 6 buf 81: 30 2e 30 30 30  &gt;0.000&lt;
420.216318     [D4] read: ret 6 buf c2: 31 34 30 30 30  &gt;14000&lt;
420.227445     [D4] read: ret 6 buf 83: 20 34 39 30 30  &gt; 4900&lt;
420.228334     [D4] read: ret 6 buf c2: 2e 30 39 30 30  &gt;.0900&lt;
420.239461     [D4] read: ret 6 buf 81: 20 30 39 30 30  &gt; 0900&lt;
420.250411     [D4] read: ret 6 buf c2: 32 37 39 30 30  &gt;27900&lt;
420.261405     [D4] read: ret 6 buf 83: 2e 30 20 30 30  &gt;.0 00&lt;
420.265468     [D4] read: ret 6 buf c3: 32 30 2e 30 30  &gt;20.00&lt;
420.269465     [D4] read: ret 6 buf 81: 38 30 2e 30 30  &gt;80.00&lt;
420.280322     [D4] read: ret 6 buf c1: 20 30 2e 30 30  &gt; 0.00&lt;
420.291469     [D4] read: ret 6 buf 82: 30 30 2e 30 30  &gt;00.00&lt;
420.302465     [D4] read: ret 6 buf c3: 30 30 31 30 30  &gt;00100&lt;
420.303511     [D4] read: ret 6 buf 82: 00 30 31 30 30  &gt;          &lt;- This has 0x00 and '0', will be read as "00"
420.303515     [D3] found null byte in status bits at 43 byte, assuming 0.
420.314425     [D4] read: ret 6 buf c1: 31 30 31 30 30  &gt;10100&lt;    &lt;- this has '1'
420.325432     [D4] read: ret 6 buf 81: 0d 30 31 30 30  &gt;.0100&lt;    &lt;- and this finishes with `\r`.
420.325442     [D3] armac command Q1 response read: '(233.0 000.0 233.0 014 49.0 27.0 20.8 00001001'</pre><pre class="screen">1.185164     [D4] armac command ID
1.316257     [D4] read: ret 6 buf c1: 23 31 00 30 30  &gt;#1
1.327309     [D4] read: ret 6 buf 81: 20 31 00 30 30  &gt; 1
1.338264     [D4] read: ret 6 buf c2: 20 20 00 30 30  &gt;
1.349151     [D4] read: ret 6 buf 83: 20 20 20 30 30  &gt;   00&lt;
1.360277     [D4] read: ret 6 buf c2: 20 20 20 30 30  &gt;   00&lt;
1.371322     [D4] read: ret 6 buf 83: 20 20 20 30 30  &gt;   00&lt;
1.382265     [D4] read: ret 6 buf c3: 20 20 20 30 30  &gt;   00&lt;
1.393156     [D4] read: ret 6 buf 82: 20 20 20 30 30  &gt;   00&lt;
1.404324     [D4] read: ret 6 buf c3: 20 20 20 30 30  &gt;   00&lt;
1.415342     [D4] read: ret 6 buf 83: 20 20 20 30 30  &gt;   00&lt;
1.426292     [D4] read: ret 6 buf c2: 20 20 20 30 30  &gt;   00&lt;
1.437203     [D4] read: ret 6 buf 83: 20 20 20 30 30  &gt;   00&lt;
1.448328     [D4] read: ret 6 buf c3: 56 34 2e 30 30  &gt;V4.00&lt;
1.459293     [D4] read: ret 6 buf 82: 31 30 2e 30 30  &gt;10.00&lt;
1.470274     [D4] read: ret 6 buf c3: 20 20 20 30 30  &gt;   00&lt;
1.481208     [D4] read: ret 6 buf 82: 20 20 20 30 30  &gt;   00&lt;
1.492261     [D4] read: ret 6 buf c1: 0d 20 20 30 30  &gt;
1.492270     [D3] armac command ID response read: '#                           V4.10     '</pre><pre class="screen">4.749667     [D4] armac command F
4.876638     [D4] read: ret 6 buf 81: 23 31 00 30 30  &gt;#1
4.887614     [D4] read: ret 6 buf c1: 32 31 00 30 30  &gt;21
4.898644     [D4] read: ret 6 buf 82: 32 30 00 30 30  &gt;20
4.909595     [D4] read: ret 6 buf c3: 2e 30 20 30 30  &gt;.0 00&lt;
4.920648     [D4] read: ret 6 buf 82: 30 30 20 30 30  &gt;00 00&lt;
4.931629     [D4] read: ret 6 buf c3: 35 20 32 30 30  &gt;5 200&lt;
4.942601     [D4] read: ret 6 buf 83: 34 2e 30 30 30  &gt;4.000&lt;
4.953666     [D4] read: ret 6 buf c2: 30 20 30 30 30  &gt;0 000&lt;
4.964535     [D4] read: ret 6 buf 83: 35 30 2e 30 30  &gt;50.00&lt;
4.975540     [D4] read: ret 6 buf c2: 30 0d 2e 30 30  &gt;0
4.975546     [D3] armac command F response read: '#220.0 005 24.00 50.0'</pre><p>## Armac R/2000I/PSW</p><pre class="screen">112.966856     [D4] armac command Q1
112.968197     [D4] armac cleanup ret i=0 ret=6 ctrl=c0         &lt;- Cleanups required.
113.091193     [D4] read: ret 6 buf 81: 28 30 0d 2e 30  &gt;(0     &lt;- Usually 1-3 bytes available in transfer.
113.103211     [D4] read: ret 6 buf c1: 30 30 0d 2e 30  &gt;00
113.115180     [D4] read: ret 6 buf 82: 30 30 0d 2e 30  &gt;00
113.117144     [D4] read: ret 6 buf c3: 2e 30 20 2e 30  &gt;.0 .0&lt;
113.120150     [D4] read: ret 6 buf 81: 31 30 20 2e 30  &gt;10 .0&lt;
113.132178     [D4] read: ret 6 buf c1: 34 30 20 2e 30  &gt;40 .0&lt;
113.144159     [D4] read: ret 6 buf 82: 30 2e 20 2e 30  &gt;0. .0&lt;
113.146149     [D4] read: ret 6 buf c3: 30 20 32 2e 30  &gt;0 2.0&lt;
113.149173     [D4] read: ret 6 buf 81: 32 20 32 2e 30  &gt;2 2.0&lt;
113.161167     [D4] read: ret 6 buf c1: 37 20 32 2e 30  &gt;7 2.0&lt;
113.173159     [D4] read: ret 6 buf 82: 2e 30 32 2e 30  &gt;.02.0&lt;
113.175157     [D4] read: ret 6 buf c3: 20 30 30 2e 30  &gt; 00.0&lt;
113.178158     [D4] read: ret 6 buf 81: 32 30 30 2e 30  &gt;200.0&lt;
113.190157     [D4] read: ret 6 buf c1: 20 30 30 2e 30  &gt; 00.0&lt;
113.202161     [D4] read: ret 6 buf 82: 30 30 30 2e 30  &gt;000.0&lt;
113.204154     [D4] read: ret 6 buf c3: 2e 30 20 2e 30  &gt;.0 .0&lt;
113.207150     [D4] read: ret 6 buf 81: 34 30 20 2e 30  &gt;40 .0&lt;
113.219174     [D4] read: ret 6 buf c1: 36 30 20 2e 30  &gt;60 .0&lt;
113.231165     [D4] read: ret 6 buf 82: 2e 38 20 2e 30  &gt;.8 .0&lt;
113.233157     [D4] read: ret 6 buf c3: 20 35 36 2e 30  &gt; 56.0&lt;
113.237149     [D4] read: ret 6 buf 81: 2e 35 36 2e 30  &gt;.56.0&lt;
113.249168     [D4] read: ret 6 buf c1: 30 35 36 2e 30  &gt;056.0&lt;
113.261155     [D4] read: ret 6 buf 83: 20 31 30 2e 30  &gt; 10.0&lt;
113.263151     [D4] read: ret 6 buf c2: 30 30 30 2e 30  &gt;000.0&lt;
113.266152     [D4] read: ret 6 buf 81: 31 30 30 2e 30  &gt;100.0&lt;
113.278161     [D4] read: ret 6 buf c1: 30 30 30 2e 30  &gt;000.0&lt;  &lt;- No Null bytes.
113.290155     [D4] read: ret 6 buf 82: 30 30 30 2e 30  &gt;000.0&lt;
113.292159     [D4] read: ret 6 buf c1: 0d 30 30 2e 30  &gt;
113.292169     [D3] armac command Q1 response read: '(000.0 140.0 227.0 002 00.0 46.8 56.0 10001000'</pre><p>Next query would return 0x80 control byte - 0 available bytes. This used to
terminate transmission, but some UPS don’t work like that.</p><p>## Armac R/3000I/PF1</p><pre class="screen">0.083301     [D4] armac command Q1
0.164847     [D4] read: ret 6 buf a6: 28 32 34 31 2e  &gt;(241.&lt;
0.184839     [D4] read: ret 6 buf 86: 35 20 30 30 30  &gt;5 000&lt;
0.205851     [D4] read: ret 6 buf a6: 2e 30 20 32 33  &gt;.0 23&lt;
0.226849     [D4] read: ret 6 buf 86: 30 2e 33 20 30  &gt;0.3 0&lt;
0.247859     [D4] read: ret 6 buf a6: 30 30 20 34 39  &gt;00 49&lt;
0.268862     [D4] read: ret 6 buf 86: 2e 39 20 32 2e  &gt;.9 2.&lt;
0.289857     [D4] read: ret 6 buf a6: 32 35 20 34 38  &gt;25 48&lt;
0.309866     [D4] read: ret 6 buf 86: 2e 30 20 30 30  &gt;.0 00&lt;
0.330863     [D4] read: ret 6 buf a6: 30 30 30 30 30  &gt;00000&lt;
0.827913     [D4] read: ret 6 buf 83: 31 0d 30 30 30  &gt;1 000&lt;
0.827927     [D3] armac command Q1 response read: '(241.5 000.0 230.3 000 49.9 2.25 48.0 00000001'
0.827954     [D4] armac command ID
1.394985     [D4] read: ret 6 buf a5: 4e 41 4b 0d 30  &gt;NAK  &lt;
1.395001     [D3] armac command ID response read: 'NAK'</pre><p>This UPS sends higher nibble set to 6 often, which exceeds available bytes.
Maybe means that more are available. Its serial-USB bridge is probably faster.
We read 5 bytes in case 6 nibble is sent. End of transmission is marked by <code class="literal">\r</code>,
no 0 nibble is sent.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_notes_2"></a>Notes</h4></div></div></div><p>You must put the generated files into the <code class="literal">drivers/</code> subdirectory, with the name of your subdriver preceded by <code class="literal">nutdrv_qx_</code>, and update <code class="literal">nutdrv_qx.c</code> by adding the appropriate <code class="literal">#include</code> line and by updating the definition of <code class="literal">subdriver_list</code>.</p><p>Please, make sure to add your driver in that list in a smart way: if your device supports also the basic commands used by the other subdrivers to claim a device, add something that is unique (i.e. not supported by the other subdrivers) to your device in your claim function and then add it on top of the slightly supported ones in that list.</p><p>You must also add the subdriver to <code class="literal">NUTDRV_QX_SUBDRIVERS</code> list variable in the <code class="literal">drivers/Makefile.am</code> and call "<code class="literal">autoreconf</code>" and/or "<code class="literal">./configure</code>" from the top level NUT directory.</p><p>You can then recompile <code class="literal">nutdrv_qx</code>, and start experimenting with the new subdriver.</p><p>For more details, have a look at the currently available subdrivers:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">nutdrv_qx_bestups.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_innovart31.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_innovart33.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_masterguard.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_mecer.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_megatec.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_megatec-old.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_mustek.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_q1.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_q2.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_q6.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_voltronic.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_voltronic-qs.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_voltronic-qs-hex.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_zinto.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li><li class="listitem">
<code class="literal">nutdrv_qx_ablerex.</code>{<code class="literal">c</code>,<code class="literal">h</code>}
</li></ul></div></div></div></div><div xmlns="" class="navfooter nut_footer"><hr />
		Last updated 2025-10-04 14:46:41 -- Network UPS Tools 2.8.4.238</div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="developers.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="sock-protocol.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>